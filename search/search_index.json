{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Arduino-LMIC library (\"MCCI LoRaWAN LMIC Library\")","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This repository contains the IBM LMIC (LoRaWAN-MAC-in-C) library, slightly modified to run in the Arduino environment, allowing using the SX1272, SX1276 transceivers and compatible modules (such as some HopeRF RFM9x modules and the Murata LoRa modules).</p> <p>Note on names: the library was originally ported to Arduino by Matthijs Kooijman and Thomas Telkamp, and was named Arduino LMIC. Subsequently, MCCI did a lot of work to support other regions, and ultimately took over maintenance. The Arduino IDE doesn't like two libraries with the same name, so we had to come up with a new name. So in the IDE, it will appear as MCCI LoRaWAN LMIC Library; but all us know it by the primary header file, which is <code>&lt;arduino_lmic.h&gt;</code>.</p> <p>Information about the LoRaWAN protocol is summarized in LoRaWAN-at-a-glance. Full information is available from the LoRa Alliance.</p> <p>A support forum is available at forum.mcci.io.</p> <p>The base Arduino library mostly exposes the functions defined by LMIC. It makes no attempt to wrap them in a higher level API that is more in the Arduino style. To find out how to use the library itself, see the examples, or see the PDF files in the doc subdirectory.</p> <p>A separate library, MCCI <code>arduino-lorawan</code>, provides a higher level, more Arduino-like wrapper which may be useful.</p> <p>The examples in this library (apart from the compliance sketch) are somewhat primitive. A very complete cross-platform Arduino application based on the LMIC has been published by Leonel Lopes Parente (<code>@lnlp</code>) as LMIC-node. That application specifically targets The Things Network.</p> <p>Although the wrappers in this library are designed to make the LMIC useful in the Arduino environment, the maintainers have tried to be careful to keep the core LMIC code generally useful. For example, I use this library without modification (but with wrappers) on a RISC-V platform in a non-Arduino environment.</p>"},{"location":"#installing","title":"Installing","text":"<p>To install this library:</p> <ul> <li>install it using the Arduino Library manager (\"Sketch\" -&gt; \"Include   Library\" -&gt; \"Manage Libraries...\"), or</li> <li>download a zip file from GitHub using the \"Download ZIP\" button and   install it using the IDE (\"Sketch\" -&gt; \"Include Library\" -&gt; \"Add .ZIP   Library...\"</li> <li>clone this git repository into your sketchbook/libraries folder.</li> </ul> <p>For more info, see https://www.arduino.cc/en/Guide/Libraries.</p>"},{"location":"#getting-help","title":"Getting Help","text":""},{"location":"#if-its-not-working","title":"If it's not working","text":"<p>Ask questions at <code>forum.mcci.io</code>. Wireless is tricky, so don't be afraid to ask. The LMIC has been used successfully in a lot of applications, but it's common to have problems getting it working. To keep the code size down, there are not a lot of debugging features, and the features are not always easy to use.</p>"},{"location":"#if-youve-found-a-bug","title":"If you've found a bug","text":"<p>Raise a GitHub issue at <code>github.com/mcci-catena/arduino-lmic</code>.</p>"},{"location":"#features","title":"Features","text":"<p>The LMIC library provides a fairly complete LoRaWAN Class A and Class B implementation, supporting the EU-868, US-915, AU-921, AS-923, and IN-866 bands. Only a limited number of features was tested using this port on Arduino hardware, so be careful when using any of the untested features.</p> <p>The library has only been tested with LoRaWAN 1.0.2/1.03 networks and does not have the separated key structure defined by LoRaWAN 1.1.</p> <p>What certainly works:</p> <ul> <li>Sending packets uplink, taking into account duty cycling.</li> <li>Encryption and message integrity checking.</li> <li>Custom frequencies and data rate settings.</li> <li>Over-the-air activation (OTAA / joining).</li> <li>Receiving downlink packets in the RX1 and RX2 windows.</li> <li>MAC command processing.</li> </ul> <p>What has not been tested:</p> <ul> <li>Class B operation.</li> <li>FSK has not been extensively tested. (Testing with the RedwoodComm RWC5020A analyzer in 2019 indicated that FSK downlink is stable but not reliable. This prevents successful completion of LoRaWAN pre-certification in regions that require support for FSK.)</li> </ul> <p>If you try one of these untested features and it works, be sure to let us know (creating a GitHub issue is probably the best way for that).</p>"},{"location":"#additional-documentation","title":"Additional Documentation","text":""},{"location":"#pdfword-documentation","title":"PDF/Word Documentation","text":"<p>The <code>doc</code> directory contains LMIC-v4.1.0.pdf, which documents the library APIs and use. It's based on the original IBM documentation, but has been adapted for this version of the library. However, as this library is used for more than Arduino, that document is supplemented by Arduino-specific details in this document.</p>"},{"location":"#adding-regions","title":"Adding Regions","text":"<p>There is a general framework for adding support for a new region. HOWTO-ADD-REGION.md has step-by-step instructions for adding a region.</p>"},{"location":"#known-bugs-and-issues","title":"Known bugs and issues","text":"<p>See the list of bugs at <code>mcci-catena/arduino-lmic</code>.</p>"},{"location":"#timing-issues","title":"Timing Issues","text":"<p>The LoRaWAN technology for class A devices requires devices to meet hard real-time deadlines. The Arduino environment doesn't provide built-in support for this, and this port of the LMIC doesn't really ensure it, either. It is your responsibility, when constructing your application, to ensure that you call <code>os_runloop_once()</code> \"often enough\".</p> <p>How often is often enough?</p> <p>It depends on what the LMIC is doing. For Class A devices, when the LMIC is idle, <code>os_runloop_once()</code> need not be called at all. However, during a message transmit, it's critical to ensure that <code>os_runloop_once()</code> is called frequently prior to hard deadlines. The API <code>os_queryTimeCriticalJobs()</code> can be used to check whether there are any deadlines due soon. Before doing work that takes <code>n</code> milliseconds, call <code>os_queryTimeCriticalJobs(ms2osticks(n))</code>, and skip the work if the API indicates that the LMIC needs attention.</p> <p>However, in the current implementation, the LMIC is tracking the completion of uplink transmits. This is done by checking for transmit-complete indications, which is done by polling. So you must also continually call <code>os_runloop_once()</code> while waiting for a transmit to be completed. This is an area for future improvement.</p>"},{"location":"#working-with-mcci-murata-based-boards","title":"Working with MCCI Murata-based boards","text":"<p>The Board Support Package V2.5.0 for the MCCI Murata-based boards (MCCI Catena 4610, MCCI Catena 4612, etc.) has a defect in clock calibration that prevents the compliance script from being used without modification. Versions V2.6.0 and later solve this issue.</p>"},{"location":"#event-handling-issues","title":"Event-Handling Issues","text":"<p>The LMIC has a simple event notification system. When an interesting event occurs, it calls a user-provided function.</p> <p>This function is sometimes called at time critical moments.</p> <p>This means that your event function should avoid doing any time-critical work.</p> <p>Furthermore, in versions of the LMIC prior to v3.0.99.3, the event function may be called in situations where it's not safe to call the general LMIC APIs. In those older LMIC versions, please be careful to defer all work from your event function to your <code>loop()</code> function. See the compliance example sketch for an elaborate version of how this can be done.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>A number of features can be enabled or disabled at compile time. This is done by adding the desired settings to the file <code>project_config/lmic_project_config.h</code>. The <code>project_config</code> directory is the only directory that contains files that you should edit to match your project; we organize things this way so that your local changes are more clearly separated from the distribution files. The Arduino environment doesn't give us a better way to do this, unless you change <code>BOARDS.txt</code>.</p> <p>Unlike other ports of the LMIC code, in this port, you should not edit <code>src/lmic/config.h</code> to configure this package. The intention is that you'll edit the <code>project_config/lmic_project_config.h</code> (if using the Arduino environment), or change compiler command-line input (if using PlatformIO, make, etc.).</p> <p>The following configuration variables are available.</p>"},{"location":"#selecting-the-lorawan-version","title":"Selecting the LoRaWAN Version","text":"<p>This library implements V1.0.3 of the LoRaWAN specification. However, it can also be used with V1.0.2. The only significant change when selecting V1.0.2 is that the US accepted power range in MAC commands is 10 dBm to 30 dBm; whereas in V1.0.3 the accepted range 2 dBm to 30 dBm.</p> <p>The default LoRaWAN version, if no version is explicitly selected, is V1.0.3.</p> <p><code>LMIC_LORAWAN_SPEC_VERSION</code> is defined as an integer reflecting the targeted spec version; it will be set to <code>LMIC_LORAWAN_SPEC_VERSION_1_0_2</code> or <code>LMIC_LORAWAN_SPEC_VERSION_1_0_3</code>. Arithmetic comparisons can be done on these version numbers: and we guarantee <code>LMIC_LORAWAN_SPEC_VERSION_1_0_3 &gt; LMIC_LORAWAN_SPEC_VERSION_1_0_2</code>, but the details of the how the versions are encoded may change, and your code should not rely upon the details.</p>"},{"location":"#selecting-v102","title":"Selecting V1.0.2","text":"<p>In <code>project_config/lmic_project_config.h</code>, add:</p> <pre><code>#define LMIC_LORAWAN_SPEC_VERSION   LMIC_LORAWAN_SPEC_VERSION_1_0_2\n</code></pre> <p>On your compiler command line, add:</p> <pre><code>-D LMIC_LORAWAN_SPEC_VERSION=LMIC_LORAWAN_SPEC_VERSION_1_0_2\n</code></pre>"},{"location":"#selecting-v103","title":"Selecting V1.0.3","text":"<p>In <code>project_config/lmic_project_config.h</code>, add:</p> <pre><code>#define LMIC_LORAWAN_SPEC_VERSION    LMIC_LORAWAN_SPEC_VERSION_1_0_3\n</code></pre> <p>On your compiler command line, add:</p> <pre><code>-D LMIC_LORAWAN_SPEC_VERSION=LMIC_LORAWAN_SPEC_VERSION_1_0_3\n</code></pre> <p>This is the default.</p>"},{"location":"#selecting-the-lorawan-region-configuration","title":"Selecting the LoRaWAN Region Configuration","text":"<p>The library supports the following regions:</p> <code>-D</code> variable CFG region name CFG region value LoRaWAN Regional Spec 1.0.3 Reference Frequency <code>-D CFG_eu868</code> <code>LMIC_REGION_eu868</code> 1 2.2 EU 863-870 MHz ISM <code>-D CFG_us915</code> <code>LMIC_REGION_us915</code> 2 2.3 US 902-928 MHz ISM <code>-D CFG_au915</code> <code>LMIC_REGION_au915</code> 5 2.6 Australia 915-928 MHz ISM <code>-D CFG_as923</code> <code>LMIC_REGION_as923</code> 7 2.8 Asia 923 MHz ISM <code>-D CFG_as923jp</code> <code>LMIC_REGION_as923</code> and <code>LMIC_COUNTRY_CODE_JP</code> 7 2.8 Asia 923 MHz ISM with Japan listen-before-talk (LBT) rules <code>-D CFG_kr920</code> <code>LMIC_REGION_kr920</code> 8 2.9 Korea 920-923 MHz ISM <code>-D CFG_in866</code> <code>LMIC_REGION_in866</code> 9 2.10 India 865-867 MHz ISM <p>The library requires that the compile environment or the project config file define exactly one of <code>CFG_...</code> variables. As released, <code>project_config/lmic_project_config.h</code> defines <code>CFG_us915</code>. If you build with PlatformIO or other environments, and you do not provide a pointer to the platform config file, <code>src/lmic/config.h</code> will define <code>CFG_eu868</code>.</p> <p>MCCI BSPs add menu entries to the Arduino IDE so you can select the target region interactively.</p> <p>The library changes configuration pretty substantially according to the region selected, and this affects the symbols in-scope in your sketches and <code>.cpp</code> files. Some of the differences are listed below. This list is not comprehensive, and is subject to change in future major releases.</p>"},{"location":"#eu868-as923-in866-kr920","title":"eu868, as923, in866, kr920","text":"<p>If the library is configured for EU868, AS923, or IN866 operation, we make the following changes:</p> <ul> <li>Add the API <code>LMIC_setupBand()</code>.</li> <li>Add the constants <code>MAX_CHANNELS</code>, <code>MAX_BANDS</code>, <code>LIMIT_CHANNELS</code>, <code>BAND_MILLI</code>,   <code>BAND_CENTI</code>, <code>BAND_DECI</code>, and <code>BAND_AUX</code>.</li> </ul>"},{"location":"#us915-au915","title":"us915, au915","text":"<p>If the library is configured for US915 operation, we make the following changes:</p> <ul> <li>Add the APIs <code>LMIC_enableChannel()</code>,   <code>LMIC_enableSubBand()</code>, <code>LMIC_disableSubBand()</code>, and <code>LMIC_selectSubBand()</code>.</li> <li>Add a number of additional <code>DR_...</code> symbols.</li> </ul>"},{"location":"#selecting-the-target-radio-transceiver","title":"Selecting the target radio transceiver","text":"<p>You should define one of the following variables. If you don't, the library assumes sx1276. There is a runtime check to make sure the actual transceiver matches the library configuration.</p> <p><code>#define CFG_sx1272_radio 1</code></p> <p>Configures the library for use with an sx1272 transceiver.</p> <p><code>#define CFG_sx1276_radio 1</code></p> <p>Configures the library for use with an sx1276 transceiver.</p>"},{"location":"#controlling-use-of-interrupts","title":"Controlling use of interrupts","text":"<p><code>#define LMIC_USE_INTERRUPTS</code></p> <p>If defined, configures the library to use interrupts for detecting events from the transceiver. If left undefined, the library will poll for events from the transceiver. See Timing for more info. Be aware that interrupts are not tested or supported on many platforms.</p>"},{"location":"#disabling-ping","title":"Disabling PING","text":"<p><code>#define DISABLE_PING</code></p> <p>If defined, removes all code needed for Class B downlink during ping slots (PING). Removes the APIs <code>LMIC_setPingable()</code> and <code>LMIC_stopPingable()</code>. Class A devices don't support PING, so defining <code>DISABLE_PING</code> is often a good idea.</p> <p>By default, PING support is included in the library.</p>"},{"location":"#disabling-beacons","title":"Disabling Beacons","text":"<p><code>#define DISABLE_BEACONS</code></p> <p>If defined, removes all code needed for handling beacons. Removes the APIs <code>LMIC_enableTracking()</code> and <code>LMIC_disableTracking()</code>.</p> <p>Enabling beacon handling allows tracking of network time, and is required if you want to enable downlink during ping slots. However, many networks don't support Class B devices. Class A devices don't support tracking beacons, so defining <code>DISABLE_BEACONS</code> might be a good idea.</p> <p>By default, beacon support is included in the library.</p>"},{"location":"#enabling-network-time-support","title":"Enabling Network Time Support","text":"<p><code>#define LMIC_ENABLE_DeviceTimeReq  number  /* boolean: 0 or non-zero */</code></p> <p>Disable or enable support for device network-time requests (LoRaWAN MAC request 0x0D). If zero, support is disabled. If non-zero, support is enabled.</p> <p>If disabled, stub routines are provided that will return failure (so you don't need conditional compiles in client code).</p> <p>By default, device network-time requests were disabled in versions prior to <code>v4.2.0-pre1</code>. As of v4.2.0-pre1, the default is that device network-time requests are enabled.</p>"},{"location":"#rarely-changed-variables","title":"Rarely changed variables","text":"<p>The remaining variables are rarely used, but we list them here for completeness.</p>"},{"location":"#changing-debug-output","title":"Changing debug output","text":"<p><code>#define LMIC_PRINTF_TO SerialLikeObject</code></p> <p>This variable should be set to the name of a <code>Serial</code>-like object (any subclass of Arduino's <code>Print</code> class), used for printing messages. If this variable is set, any calls to the standard <code>printf</code> function (or more generally all writes to the global <code>stdout</code> file descriptor) will redirected to the specified stream.</p> <p>When this is not defined, <code>printf</code> and <code>stdout</code> are untouched and their behavior might vary among boards (and could print to somewhere, but also throw away output or crash). So if you want to use <code>printf</code> or <code>LMIC_DEBUG_LEVEL</code>, make sure to also define this.</p>"},{"location":"#getting-debug-from-the-rf-library","title":"Getting debug from the RF library","text":"<p><code>#define LMIC_DEBUG_LEVEL number /* 0, 1, or 2 */</code></p> <p>This variable determines the amount of debug output to be produced by the library. The default is <code>0</code>.</p> <p>If <code>LMIC_DEBUG_LEVEL</code> is zero, no output is produced. If <code>1</code>, limited output is produced. If <code>2</code>, more extensive output is produced.</p> <p>Note that debug output will influence the timing of various parts of the library and could introduce timing problems (especially in the RX window timing), so use it carefully.</p> <p>Debug output is generated using the standard <code>printf</code> function, so unless your environment already redirects <code>printf</code> / <code>stdout</code> somewhere, you should also configure <code>LIMC_PRINTF_TO</code>.</p>"},{"location":"#selecting-the-aes-library","title":"Selecting the AES library","text":"<p>The library comes with two AES implementations. The original implementation is better on ARM processors because it's faster, but it's larger. For smaller AVR8 processors, a second library (\"IDEETRON\") is provided that has a smaller code footprint. You may define one of the following variables to choose the AES implementation. If you don't, the library uses the IDEETRON version.</p> <p><code>#define USE_ORIGINAL_AES</code></p> <p>If defined, the original AES implementation is used.</p> <p><code>#define USE_IDEETRON_AES</code></p> <p>If defined, the IDEETRON AES implementation is used.</p>"},{"location":"#defining-the-os-tick-frequency","title":"Defining the OS Tick Frequency","text":"<p><code>#define US_PER_OSTICK_EXPONENT number</code></p> <p>This variable should be set to the base-2 logarithm of the number of microseconds per OS tick. The default is 4, which indicates that each tick corresponds to 16 microseconds (because 16 == 2^4).</p>"},{"location":"#setting-the-spi-bus-frequency","title":"Setting the SPI-bus frequency","text":"<p><code>#define LMIC_SPI_FREQ floatNumber</code></p> <p>This variable sets the default frequency for the SPI bus connection to the transceiver. The default is <code>1E6</code>, meaning 1 MHz. However, this can be overridden by the contents of the <code>lmic_pinmap</code> structure, and we recommend that you use that approach rather than editing the <code>project_config/lmic_project_config.h</code> file.</p>"},{"location":"#changing-handling-of-runtime-assertion-failures","title":"Changing handling of runtime assertion failures","text":"<p>The variables <code>LMIC_FAILURE_TO</code> and <code>DISABLE_LMIC_FAILURE_TO</code> control the handling of runtime assertion failures. By default, assertion messages are displayed using the <code>Serial</code> object. You can define LMIC_FAILURE_TO to be the name of some other <code>Print</code>-like object. You can also define <code>DISABLE_LMIC_FAILURE_TO</code> to any value, in which case assert failures will silently halt execution.</p>"},{"location":"#disabling-join","title":"Disabling JOIN","text":"<p><code>#define DISABLE_JOIN</code></p> <p>If defined, removes code needed for OTAA activation. Removes the APIs <code>LMIC_startJoining()</code> and <code>LMIC_tryRejoin()</code>.</p>"},{"location":"#disabling-class-a-mac-commands","title":"Disabling Class A MAC commands","text":"<p><code>DISABLE_MCMD_DutyCycleReq</code>, <code>DISABLE_MCMD_RXParamSetupReq</code>, <code>DISABLE_MCMD_RXTimingSetupReq</code>, <code>DISABLE_MCMD_NewChannelReq</code>, and <code>DISABLE_MCMD_DlChannelReq</code> respectively disable code for various Class A MAC commands.</p>"},{"location":"#disabling-class-b-mac-commands","title":"Disabling Class B MAC commands","text":"<p><code>DISABLE_MCMD_PingSlotChannelReq</code> disables the PING_SET MAC commands. It's implied by <code>DISABLE_PING</code>.</p> <p><code>ENABLE_MCMD_BeaconTimingAns</code> enables the next-beacon start command. It's disabled by default, and overridden (if enabled) by <code>DISABLE_BEACON</code>. (This command is deprecated.)</p>"},{"location":"#disabling-user-events","title":"Disabling user events","text":"<p>Code to handle registered callbacks for transmit, receive, and events can be suppressed by setting <code>LMIC_ENABLE_user_events</code> to zero. This C preprocessor macro is always defined as a post-condition of <code>#include \"config.h\"</code>; if non-zero, user events are supported, if zero, user events are not-supported. The default is to support user events.</p>"},{"location":"#disabling-external-reference-to-onevent","title":"Disabling external reference to <code>onEvent()</code>","text":"<p>In V3 of the LMIC, you do not need to define a function named <code>onEvent</code>. The LMIC will notice that there's no such function, and will suppress the call. However, be cautious -- in a large software package, <code>onEvent()</code> may be defined for some other purpose. The LMIC has no way of knowing that this is not the LMIC's <code>onEvent</code>, so it will call the function, and this may cause problems.</p> <p>All reference to <code>onEvent()</code> can be suppressed by setting <code>LMIC_ENABLE_onEvent</code> to 0. This C preprocessor macro is always defined as a post-condition of <code>#include \"config.h\"</code>; if non-zero, a weak reference to <code>onEvent()</code> will be used; if zero, the user <code>onEvent()</code> function is not supported, and the client must register an event handler explicitly. See the PDF documentation for details on <code>LMIC_registerEventCb()</code>.</p>"},{"location":"#enabling-long-messages","title":"Enabling long messages","text":"<p>By default, LMIC allows messages up to 255 bytes, as defined in the LoRaWAN standard and required by compliance testing. To save RAM for simple devices, this can be limited using the <code>LMIC_MAX_FRAME_LENGTH</code> macro. This macro defines the length of the full frame, the maximum payload size is a bit smaller (and can be read from the <code>MAX_LEN_PAYLOAD</code> constant).</p> <p>This value controls both the TX and RX buffers, so reducing it by 1 saves 2 bytes of RAM. The value should be not be set too small, since that can prevent properly receiving network downlinks (e.g. join accepts or MAC commands). Using <code>#define LMIC_MAX_FRAME_LENGTH 64</code> is common and should be big enough for most operation, while saving 384 bytes of RAM.</p> <p>Originally, this was configured using the <code>LMIC_ENABLE_long_messages</code> macro, which is still supported for compatibility. Setting <code>LMIC_ENABLE_long_messages</code> to 0 is equivalent to setting <code>LMIC_MAX_FRAME_LENGTH</code> to 64.</p>"},{"location":"#enabling-lmic-event-logging-calls","title":"Enabling LMIC event logging calls","text":"<p>When debugging the LMIC, debug prints change timing, and can make things not work at all. The LMIC has embedded optional calls to capture debug information that can be printed out later, when the LMIC is not active. Logging is enabled by setting <code>LMIC_ENABLE_event_logging</code> to 1. The default is not to log. This C preprocessor macro is always defined as a post-condition of <code>#include \"config.h\"</code>.</p> <p>The compliance test script includes a suitable logging implementation; the other example scripts do not.</p>"},{"location":"#special-purpose","title":"Special purpose","text":"<p><code>#define DISABLE_INVERT_IQ_ON_RX</code> disables the inverted Q-I polarity on RX. Use of this variable is deprecated, see issue #250. Rather than defining this, set the value of <code>LMIC.noRXIQinversion</code>. If set non-zero, receive will be non-inverted. End-devices will be able to receive messages from each other, but will not be able to hear the gateway (other than Class B beacons)aa. If set zero, (the default), end devices will only be able to hear gateways, not each other.</p>"},{"location":"#supported-hardware","title":"Supported hardware","text":"<p>This library is intended to be used with plain LoRa transceivers, connecting to them using SPI. In particular, the SX1272 and SX1276 families are supported (which should include SX1273, SX1277, SX1278 and SX1279 which only differ in the available frequencies, bandwidths and spreading factors). It has been tested with both SX1272 and SX1276 chips, using the Semtech SX1272 evaluation board and the HopeRF RFM92 and RFM95 boards (which supposedly contain an SX1272 and SX1276 chip respectively).</p> <p>This library contains a full LoRaWAN stack and is intended to drive these Transceivers directly. It is not intended to be used with full-stack devices like the Microchip RN2483 and the Embit LR1272E. These contain a transceiver and microcontroller that implements the LoRaWAN stack and exposes a high-level serial interface instead of the low-level SPI transceiver interface.</p> <p>This library is intended to be used inside the Arduino environment. It should be architecture-independent. Users have tested this on AVR, ARM, Xtensa-based, and RISC-V based system.</p> <p>This library can be quite heavy on small systems, especially if the fairly small ATmega 328p (such as in the Arduino Uno) is used. In the default configuration, the available 32K flash space is nearly filled up (this includes some debug output overhead, though). By disabling some features in <code>project_config/lmic_project_config.h</code> (like beacon tracking and ping slots, which are not needed for Class A devices), some space can be freed up.</p>"},{"location":"#pre-integrated-boards","title":"Pre-Integrated Boards","text":"<p>There are two ways of using this library, either with pre-integrated boards or with manually configured boards.</p> <p>The following boards are pre-integrated.</p> <ul> <li>Adafruit Feather 32u4 LoRa 900 MHz (SX1276)</li> <li>Adafruit Feather M0 LoRa 900 MHz (SX1276)</li> <li>MCCI Catena 4410, 4420, 4450, 4460 and 4470 boards (based on Adafruit Feather boards plus wings) (SX1276)</li> <li>MCCI Catena 4551, 4610, 4611, 4612, 4617, 4618, 4630, 4801 and 480212 boards (based on the Murata CMWX1ZZABZ-078 module) (SX1276)</li> <li>TTGo LoRa32 V1 (based on the ESP32)</li> <li>Heltec WiFi LoRa 32 V2 (based on the ESP32)</li> </ul> <p>To help you know if you have to worry, we'll call such boards \"pre-integrated\" and prefix each section with suitable guidance.</p>"},{"location":"#platformio","title":"PlatformIO","text":"<p>For use with PlatformIO, the <code>lmic_project_config.h</code> has to be disabled with the flag <code>ARDUINO_LMIC_PROJECT_CONFIG_H_SUPPRESS</code>. The settings are defined in PlatformIO by <code>build_flags</code>.</p> <pre><code>lib_deps =\nMCCI LoRaWAN LMIC library\nbuild_flags =\n-D ARDUINO_LMIC_PROJECT_CONFIG_H_SUPPRESS\n-D CFG_eu868=1\n-D CFG_sx1276_radio=1\n</code></pre>"},{"location":"#manual-configuration","title":"Manual configuration","text":"<p>If your desired transceiver board is not pre-integrated, you need to provide the library with the required information.</p> <p>You may need to wire up your transceiver. The exact connections are a bit dependent on the transceiver board and Arduino used, so this section tries to explain what each connection is for and in what cases it is (not) required.</p> <p>Note that the SX127x module runs at 3.3V and likely does not like 5V on its pins (though the datasheet is not say anything about this, and my transceiver did not obviously break after accidentally using 5V I/O for a few hours). To be safe, make sure to use a level shifter, or an Arduino running at 3.3V. The Semtech evaluation board has 100 ohm resistors in series with all data lines that might prevent damage, but I would not count on that.</p>"},{"location":"#power","title":"Power","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>The SX127x transceivers need a supply voltage between 1.8V and 3.9V. Using a 3.3V supply is typical. Some modules have a single power pin (like the HopeRF modules, labeled 3.3V) but others expose multiple power pins for different parts (like the Semtech evaluation board that has <code>VDD_RF</code>, <code>VDD_ANA</code> and <code>VDD_FEM</code>), which can all be connected together. Any GND pins need to be connected to the Arduino GND pin(s).</p>"},{"location":"#spi","title":"SPI","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>The primary way of communicating with the transceiver is through SPI (Serial Peripheral Interface). This uses four pins: MOSI, MISO, SCK and SS. The former three need to be directly connected: so MOSI to MOSI, MISO to MISO, SCK to SCK. Where these pins are located on your Arduino varies, see for example the \"Connections\" section of the Arduino SPI documentation.</p> <p>The SS (slave select) connection is a bit more flexible. On the SPI slave side (the transceiver), this must be connect to the pin (typically) labeled NSS. On the SPI master (Arduino) side, this pin can connect to any I/O pin. Most Arduinos also have a pin labeled \"SS\", but this is only relevant when the Arduino works as an SPI slave, which is not the case here. Whatever pin you pick, you need to tell the library what pin you used through the pin mapping (see below).</p>"},{"location":"#dio-pins","title":"DIO pins","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>The DIO (digital I/O) pins on the SX127x can be configured for various functions. The LMIC library uses them to get instant status information from the transceiver. For example, when a LoRa transmission starts, the DIO0 pin is configured as a TxDone output. When the transmission is complete, the DIO0 pin is made high by the transceiver, which can be detected by the LMIC library.</p> <p>The LMIC library needs only access to DIO0, DIO1 and DIO2, the other DIOx pins can be left disconnected. On the Arduino side, they can connect to any I/O pin. If interrupts are used, the accuracy of timing will be improved, particularly the rest of your <code>loop()</code> function has lengthy calculations; but in that case, the enabled DIO pins must all support rising-edge interrupts. See the Timing section below.</p> <p>In LoRa mode the DIO pins are used as follows:</p> <ul> <li>DIO0: TxDone and RxDone</li> <li>DIO1: RxTimeout</li> </ul> <p>In FSK mode they are used as follows::</p> <ul> <li>DIO0: PayloadReady and PacketSent</li> <li>DIO2: TimeOut</li> </ul> <p>Both modes need only 2 pins, but the transceiver does not allow mapping them in such a way that all needed interrupts map to the same 2 pins. So, if both LoRa and FSK modes are used, all three pins must be connected.</p> <p>The pins used on the Arduino side should be configured in the pin mapping in your sketch, by setting the values of <code>lmic_pinmap::dio[0]</code>, <code>[1]</code>, and <code>[2]</code> (see below).</p>"},{"location":"#reset","title":"Reset","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>The transceiver has a reset pin that can be used to explicitly reset it. The LMIC library uses this to ensure the chip is in a consistent state at startup. In practice, this pin can be left disconnected, since the transceiver will already be in a sane state on power-on, but connecting it might prevent problems in some cases.</p> <p>On the Arduino side, any I/O pin can be used. The pin number used must be configured in the pin mapping <code>lmic_pinmap::rst</code> field (see below).</p>"},{"location":"#rxtx","title":"RXTX","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>The transceiver contains two separate antenna connections: One for RX and one for TX. A typical transceiver board contains an antenna switch chip, that allows switching a single antenna between these RX and TX connections. Such a antenna switcher can typically be told what position it should be through an input pin, often labeled RXTX.</p> <p>The easiest way to control the antenna switch is to use the RXTX pin on the SX127x transceiver. This pin is automatically set high during TX and low during RX. For example, the HopeRF boards seem to have this connection in place, so they do not expose any RXTX pins and the pin can be marked as unused in the pin mapping.</p> <p>Some boards do expose the antenna switcher pin, and sometimes also the SX127x RXTX pin. For example, the SX1272 evaluation board calls the former FEM_CTX and the latter RXTX. Again, simply connecting these together with a jumper wire is the easiest solution.</p> <p>Alternatively, or if the SX127x RXTX pin is not available, LMIC can be configured to control the antenna switch. Connect the antenna switch control pin (e.g. FEM_CTX on the Semtech evaluation board) to any I/O pin on the Arduino side, and configure the pin used in the pin map (see below).</p> <p>The configuration entry <code>lmic_pinmap::rxtx</code> configures the pin to be used for the RXTX control function, in terms of the Arduino <code>wire.h</code> digital pin number. If set to <code>LMIC_UNUSED_PIN</code>, then the library assumes that software does not need to control the antenna switch.</p>"},{"location":"#rxtx-polarity","title":"RXTX Polarity","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>If an external switch is used, you also must specify the polarity. Some modules want RXTX to be high for transmit, low for receive; Others want it to be low for transmit, high for receive. The Murata module, for example, requires that RXTX be high for receive, low for transmit.</p> <p>The configuration entry <code>lmic_pinmap::rxtx_rx_active</code> should be set to the state to be written to the RXTX pin to make the receiver active. The opposite state is written to make the transmitter active. If <code>lmic_pinmap::rxtx</code> is <code>LMIC_UNUSED_PIN</code>, then the value of <code>lmic_pinmap::rxtx_rx_active</code> is ignored.</p>"},{"location":"#pin-mapping","title":"Pin mapping","text":"<p>If you're using a pre-integrated board, you can skip this section.</p> <p>Refer to the documentation on your board for the required settings.</p> <p>Remember, for pre-integrated boards, you don't worry about this.</p> <p>We have details for the following manually-configured boards here:</p> <ul> <li>LoRa Nexus by Ideetron</li> </ul> <p>If your board is not configured, you need at least to provide your own <code>lmic_pinmap</code>. As described above, a variety of configurations are possible. To tell the LMIC library how your board is configured, you must declare a variable containing a pin mapping struct in your sketch file. If you call <code>os_init()</code> to initialize the LMIC, you must name this structure <code>lmic_pins</code>. If you call <code>os_init_ex()</code>, you may name the structure what you like, but you pass a pointer as the parameter to <code>os_init_ex()</code>.</p> <p>Here's an example of a simple initialization:</p> <pre><code>  lmic_pinmap lmic_pins = {\n.nss = 6,\n.rxtx = LMIC_UNUSED_PIN,\n.rst = 5,\n.dio = {2, 3, 4},\n// optional: set polarity of rxtx pin.\n.rxtx_rx_active = 0,\n// optional: set RSSI cal for listen-before-talk\n// this value is in dB, and is added to RSSI\n// measured prior to decision.\n// Must include noise guardband! Ignored in US,\n// EU, IN, other markets where LBT is not required.\n.rssi_cal = 0,\n// optional: override LMIC_SPI_FREQ if non-zero\n.spi_freq = 0,\n};\n</code></pre> <p>The names refer to the pins on the transceiver side, the numbers refer to the Arduino pin numbers (to use the analog pins, use constants like <code>A0</code>). For the DIO pins, the three numbers refer to DIO0, DIO1 and DIO2 respectively. Any pins that are not needed should be specified as <code>LMIC_UNUSED_PIN</code>. The NSS and dio0 pins are required. The others can potentially left out (depending on the environments and requirements, see the notes above for when a pin can or cannot be left out).</p>"},{"location":"#advanced-initialization","title":"Advanced initialization","text":"<p>In some boards require much more advanced management. The LMIC has a very flexible framework to support this, but it requires you to do some C++ work.</p> <ol> <li> <p>You must define a new class derived from <code>Arduino_LMIC::HalConfiguration_t</code>. (We'll call this <code>cMyHalConfiguration_t</code>).</p> </li> <li> <p>This class may define overrides for several methods (discussed below).</p> </li> <li> <p>You must create an instance of your class, e.g.</p> </li> </ol> <pre><code>cMyHalConfiguration_t myHalConfigInstance;\n</code></pre> <ol> <li>You add another entry in your <code>lmic_pinmap</code>, <code>pConfig = &amp;myHalConfigInstance</code>, to link your pin-map to your object.</li> </ol> <p>The full example looks like this:</p> <pre><code>class cMyHalConfiguration_t : public Arduino_LMIC::HalConfiguration_t\n{\npublic:\n// ...\n// put your method function override declarations here.\n// this example uses RFO at 10 dBm or less, PA_BOOST up to 17 dBm,\n// or the high-power mode above 17 dBm. In other words, it lets the\n// LMIC-determined policy determine what's to be done.\nvirtual TxPowerPolicy_t getTxPowerPolicy(\nTxPowerPolicy_t policy,\nint8_t requestedPower,\nuint32_t frequency\n) override\n{\nreturn policy;\n}\n};\n</code></pre>"},{"location":"#halconfiguration_t-methods","title":"HalConfiguration_t methods","text":"<ul> <li> <p><code>ostime_t setModuleActive(bool state)</code> is called by the LMIC to make the module active or to deactivate it (the value of <code>state</code> is true to activate). The implementation must turn power to the module on and otherwise prepare for it to go to work, and must return the number of OS ticks to wait before starting to use the radio.</p> </li> <li> <p><code>void begin(void)</code> is called during initialization, and is your code's chance to do any early setup.</p> </li> <li> <p><code>void end(void)</code> is (to be) called during late shutdown. (Late shutdown is not implemented yet; but we wanted to add the API for consistency.)</p> </li> <li> <p><code>bool queryUsingTcxo(void)</code> shall return <code>true</code> if the module uses a TCXO; <code>false</code> otherwise.</p> </li> <li> <p><code>TxPowerPolicy_t getTxPowerPolicy(TxPowerPolicy_t policy, int8_t requestedPower, uint32_t frequency)</code> allows you to override the LMIC's selection of transmit power. If not provided, the default method forces the LMIC to use PA_BOOST mode. (We chose to do this because we found empirically that the Hope RF module doesn't support RFO, and because legacy LMIC code never used anything except PA_BOOST mode.)</p> </li> </ul> <p>Caution: the LMIC has no way of knowing whether the mode you return makes sense. Use of 20 dBm mode without limiting duty cycle can over-stress your module. The LMIC currently does not have any code to duty-cycle US transmissions at 20 dBm. If properly limiting transmissions to 400 milliseconds, a 1% duty-cycle means at most one message every 40 seconds. This shouldn't be a problem in practice, but buggy upper level software still might do things more rapidly.</p>"},{"location":"#lora-nexus-by-ideetron","title":"LoRa Nexus by Ideetron","text":"<p>This board uses the following pin mapping:</p> <pre><code>  const lmic_pinmap lmic_pins = {\n.nss = 10,\n.rxtx = LMIC_UNUSED_PIN,\n.rst = LMIC_UNUSED_PIN, // hardwired to AtMega RESET\n.dio = {4, 5, 7},\n};\n</code></pre>"},{"location":"#example-sketches","title":"Example Sketches","text":"<p>This library provides several examples.</p> <ul> <li> <p><code>ttn-otaa.ino</code> shows a basic transmission of a \"Hello, world!\" message   using the LoRaWAN protocol. It contains some frequency settings and   encryption keys intended for use with The Things Network, but these   also correspond to the default settings of most gateways, so it   should work with other networks and gateways as well.   The example uses over-the-air activation (OTAA) to first join the network to establish a   session and security keys. This was tested with The Things Network,   but should also work (perhaps with some changes) for other networks.   OTAA is the preferred way to work with production LoRaWAN networks.</p> </li> <li> <p><code>ttn-otaa-feather-us915.ino</code> is a version of <code>ttn-otaa.ino</code> that has   been configured for use with the Feather M0 LoRa, in the US915 region,   with The Things Network. Remember that you may also have to change <code>config.h</code>   from defaults. This sketch also works with the MCCI Catena family of products   as well as with the Feather 32u4 LoRa.</p> </li> <li> <p><code>ttn-otaa-halconfig-us915.ino</code> is a version of <code>ttn-otaa.ino</code> that uses the LMIC automatic configuration system, in the US915 region,   with The Things Network. Remember that you may also have to change <code>config.h</code>   from defaults. This sketch works with all the boards listed above under Pre-Integrated Boards.</p> </li> <li> <p><code>ttn-otaa-feather-us915-dht22.ino</code>   is a further refinement of <code>ttn-otaa-feather-us915.ino</code>. It measures and   transmits temperature and relative humidity using a DHT22 sensor. It's only   been tested with Feather M0-family products.</p> </li> <li> <p><code>raw.ino</code> shows how to access the radio on a somewhat low level,   and allows to send raw (non-LoRaWAN) packets between nodes directly.   This is useful to verify basic connectivity, and when no gateway is   available, but this example also bypasses duty cycle checks, so be   careful when changing the settings.</p> </li> <li> <p><code>raw-feather.ino</code> is a version of <code>raw.ino</code> that is completely configured   for the Adafruit Feather M0 LoRa, and for a variety   of other MCCI products.</p> </li> <li> <p><code>raw-halconfig.ino</code> is like the other <code>raw</code> examples, but is most general. It's configured according to the LMIC's auto-configuration mechanism, and adapts according to the selected region.</p> </li> <li> <p><code>ttn-abp.ino</code> shows a basic transmission of a \"Hello, world!\" message   using the LoRaWAN protocol. This example   uses activation-by-personalization (ABP, preconfiguring a device   address and encryption keys), and does not employ over-the-air   activation.</p> </li> </ul> <p>ABP should not be used if you have access to a production gateway and network; it's   not compliant with LoRaWAN standards, it's not FCC compliant, and it's uses spectrum   in a way that's unfair to other users. However, it's often the most economical way to   get your feet wet with this technology. It's possible to do ABP compliantly with the LMIC   framework, but you need to have FRAM storage and a framework that saves uplink and   downlink counts across reboots and resets. See, for example,   Catena-Arduino-Platform.</p> <ul> <li><code>ttn-abp-feather-us915-dht22.ino</code>   refines <code>ttn-abp.ino</code> by configuring for use with the Feather M0 LoRa in the US915 region,   with a single-channel gateway on The Things Network; it measures and transmits temperature and relative   humidity using a DHT22 sensor. It's only been tested with Feather M0-family products.</li> </ul> <p>ABP should not be used if you have access to a production gateway and network; it's   not compliant with LoRaWAN standards, it's not FCC compliant, and it's uses spectrum   in a way that's unfair to other users. However, it's often the most economical way to   get your feet wet with this technology. It's possible to do ABP compliantly with the LMIC   framework, but you need to have FRAM storage and a framework that saves uplink and   downlink counts across reboots and resets. See, for example,   Catena-Arduino-Platform.</p> <ul> <li> <p><code>header_test.ino</code> just tests the header files; it's used for regression testing.</p> </li> <li> <p><code>compliance-otaa-halconfig.ino</code> is a test sketch that is used for LoRaWAN compliance testing.</p> </li> <li> <p><code>helium-otaa.ino</code> is a complete example for using the LMIC on the Helium network. It's very similar to the OTAA examples, but sets up the prejoin parameters properly for the initial deployment of Helium LoRaWAN support.</p> </li> <li> <p><code>ttn-otaa-network-time.ino</code> demonstrates use of the network time request. Network time requests are not supported by The Things Network as of the time of writing.</p> </li> </ul>"},{"location":"#timing","title":"Timing","text":"<p>The library is responsible for keeping track of time of certain network events, and scheduling other events relative to those events. For Class A uplink transmissions, the library must note when a packet finishes transmitting, so it can open up the RX1 and RX2 receive windows at a fixed time after the end of transmission. The library does this by watching for rising edges on the DIO0 output of the SX127x, and noting the time.</p> <p>The library observes and processes rising edges on the pins as part of <code>os_runloop()</code> processing. This can be configured in one of two ways (see Controlling use of interrupts). See Interrupts and Arduino system timing for implementation details.</p> <p>By default, the library polls the enabled pins to determine whether an event has occurred. This approach allows use of any CPU pin to sense the DIOs, and makes no assumptions about interrupts. However, it means that the end-of-transmit event is not observed (and time-stamped) until <code>os_runloop_once()</code> is called.</p> <p>Optionally, you can configure the LMIC library to use interrupts. The interrupt handlers capture the time of the event. Actual processing is done the next time that <code>os_runloop_once()</code> is called, using the captured time. However, this requires that the DIO pins be wired to Arduino pins that support rising-edge interrupts, and it may require custom initialization code on your platform to hook up the interrupts.</p>"},{"location":"#controlling-protocol-timing","title":"Controlling protocol timing","text":"<p>The timing of end-of-transmit interrupts is used to determine when to open the downlink receive window. Because of the considerations above, some inaccuracy in the time stamp for the end-of-transmit interrupt is inevitable.</p> <p>Fortunately, the timing of the receive windows at the device need not be extremely accurate; the LMIC has to turn on the receiver early enough to capture a downlink from the gateway and must leave the receiver on long enough to compensate for timing errors due to various inaccuracies. To make it easier for the device to catch downlinks, the gateway first transmits a preamble consisting of 8 symbols. The SX127x receiver needs to see at least 4 symbols to detect a message. The Arduino LMIC tries to enable the receiver for 6 symbol times slightly before the start of the receive window.</p> <p>The HAL bases all timing on the Arduino <code>micros()</code> timer, which has a platform-specific granularity and accuracy, and is based on the primary microcontroller clock.</p> <p>If using an internal oscillator that is less than 100ppm accurate but better than 4000 ppm accurate, or if your other <code>loop()</code> processing is time consuming, you can use <code>LMIC_setClockError()</code> to cause the library to leave the radio on longer. Note that for various reasons, it is not practical to set enormous clock errors. Oscillators that are 4000 ppm accurate or worse should be supplemented or disciplined with a better timing source. The LoRaWAN spec, for class B, implicitly assumes 100 ppm accuracy in the clock.</p> <p>Users of older versions of the library were advised to set large clock errors if they were experiencing timing problems. However, close analysis and debugging during the preparation of v3.1.0 of this library revealed that the real errors were in the timing calculations in the library. Once those were corrected, the need for large clock error settings was reduced. It's still possible to use large clock errors if needed, but this must be enabled via a compile time switch.</p> <p>An even more accurate solution could be to use a dedicated timer with an input capture unit, that can store the timestamp of a change on the DIO0 pin (the only one that is timing-critical) entirely in hardware. Experience shows that this is not normally required, so we leave this as a customization to be performed on a platform-by-platform basis. We provide a special API, <code>radio_irq_handler_v2(u1_t dio, ostime_t tEvent)</code>. This API allows you to supply a hardware-captured time for extra accuracy.</p> <p>The practical consequence of inaccurate timing is reduced battery life; the LMIC must turn on the receiver earlier in order to be sure to capture downlink packets. However, this is a second order effect on class A devices; every receive is preceded by a transmit, which takes approximately ten times as much power per millisecond as a receive.</p>"},{"location":"#lmic_setclockerror","title":"<code>LMIC_setClockError()</code>","text":"<p>You may call this routine during initialization to inform the LMIC code about the timing accuracy of your system.</p> <pre><code>enum { MAX_CLOCK_ERROR = 65535 };\nvoid LMIC_setClockError(\nu2_t error\n);\n</code></pre> <p>This function sets the anticipated relative clock error. <code>MAX_CLOCK_ERROR</code> represents +/- 100%, and 0 represents no additional clock compensation. To allow for an error of 20%, you would call</p> <pre><code>LMIC_setClockError(MAX_CLOCK_ERROR * 20 / 100);\n</code></pre> <p>Setting a high clock error causes the RX windows to be opened earlier than it otherwise would be. This causes more power to be consumed. For Class A devices, this extra power is not substantial, but for Class B devices, this can be significant.</p> <p>For a variety of reasons, the LMIC normally ignores clock errors greater than 4000 ppm (0.4%). The compile-time flag <code>LMIC_ENABLE_arbitrary_clock_error</code> can remove this limit. To do this, define it to a non-zero value.</p> <p>This clock error is not reset by <code>LMIC_reset()</code>.</p>"},{"location":"#interrupts-and-arduino-system-timing","title":"Interrupts and Arduino system timing","text":"<p>The IBM LMIC used as the basis for this code disables interrupts while the radio driver is active, to prevent reentrancy via <code>radio_irq_handler()</code> at unexpected moments. It uses <code>os_getTime()</code>, and assumes that <code>os_getTime()</code> still works when interrupts were disabled. This causes problems on Arduino platforms. Most board support packages use interrupts to advance <code>millis()</code> and <code>micros()</code>, and with these BSPs, <code>millis()</code> and <code>micros()</code> return incorrect values while interrupts are disabled. Although some BSPs (like the ones provided by MCCI) provide real time correctly while interrupts are disabled, this is not portable. It's not practical to make such changes in every BSP.</p> <p>To avoid this, the LMIC processes events in several steps; these steps ensure that <code>radio_irq_handler_v2()</code> is only called at predictable times.</p> <ol> <li> <p>If interrupts are enabled via <code>LMIC_USE_INTERRUPTS</code>, hardware interrupts catch the time of the interrupt and record that the interrupt occurred. These routines rely on hardware edge-sensitive interrupts. If your hardware interrupts are level-sensitive, you must mask the interrupt somehow at the ISR. You can't use SPI routines to talk to the radio, because this may leave the SPI system and the radio in undefined states. In this configuration, <code>hal_io_pollIRQs()</code> exists but is a no-op.</p> </li> <li> <p>If interrupts are not enabled via <code>LMIC_USE_INTERRUPTS</code>, the digital I/O lines are polled every so often by calling the routine <code>hal_io_pollIRQs()</code>. This routine watches for edges on the relevant digital I/O lines, and records the time of transition.</p> </li> <li> <p>The LMIC <code>os_runloop_once()</code> routine calls <code>hal_processPendingIRQs()</code>. This routine uses the timestamps captured by the hardware ISRs and <code>hal_io_pollIRQs()</code> to invoke <code>radio_irq_hander_v2()</code> with the appropriate information. <code>hal_processPendingIRQs()</code> in turn calls <code>hal_io_pollIRQs()</code> (in case interrupts are not configured).</p> </li> <li> <p>For compatibility with older versions of the Arduino LMIC, <code>hal_enableIRQs()</code> also calls <code>hal_io_pollIRQs()</code> when enabling interrupts. However, it does not dispatch the interrupts to <code>radio_irq_handler_v2()</code>; this must be done by a subsequent call to <code>hal_processPendingIRQs()</code>.</p> </li> </ol>"},{"location":"#downlink-data-rate","title":"Downlink data rate","text":"<p>Note that the data rate used for downlink packets in the RX2 window varies by region. Consult your network's manual for any divergences from the LoRaWAN Regional Parameters. This library assumes that the network follows the regional default.</p> <p>Some networks use different values than the specification. For example, in Europe, the specification default is DR0 (SF12, 125 kHz bandwidth). However, iot.semtech.com and The Things Network both used SF9 / 125 kHz or DR3). If using over-the-air activation (OTAA), the network will download RX2 parameters as part of the JoinAccept message; the LMIC will honor the downloaded parameters.</p> <p>However, when using personalized activate (ABP), it is your responsibility to set the right settings, e.g. by adding this to your sketch (after calling <code>LMIC_setSession</code>). <code>ttn-abp.ino</code> already does this.</p> <pre><code>LMIC.dn2Dr = DR_SF9;\n</code></pre>"},{"location":"#encoding-utilities","title":"Encoding Utilities","text":"<p>It is generally important to make LoRaWAN messages as small as practical. Extra bytes mean extra transmit time, which wastes battery power and interferes with other nodes on the network.</p> <p>To simplify coding, the Arduino header file  defines some data encoding utility functions to encode floating-point data into <code>uint16_t</code> values using <code>sflt16</code> or <code>uflt16</code> bit layout. For even more efficiency, there are versions that use only the bottom 12 bits of the <code>uint16_t</code>, allowing for other bits to be carried in the top 4 bits, or for two values to be crammed into three bytes. <ul> <li><code>uint16_t LMIC_f2sflt16(float)</code> converts a floating point number to a <code>sflt16</code>-encoded <code>uint16_t</code>.</li> <li><code>uint16_t LMIC_f2uflt16(float)</code> converts a floating-point number to a <code>uflt16</code>-encoded <code>uint16_t</code>.</li> <li><code>uint16_t LMIC_f2sflt12(float)</code> converts a floating-point number to a <code>sflt12</code>-encoded <code>uint16_t</code>, leaving the top four bits of the result set to zero.</li> <li><code>uint16_t LMIC_f2uflt12(float)</code> converts a floating-point number to a <code>uflt12</code>-encoded <code>uint16_t</code>, leaving the top four bits of the result set to zero.</li> </ul> <p>JavaScript code for decoding the data can be found in the following sections.</p>"},{"location":"#sflt16","title":"sflt16","text":"<p>A <code>sflt16</code> datum represents an unsigned floating point number in the range [0, 1.0), transmitted as a 16-bit field. The encoded field is interpreted as follows:</p> bits description 15 Sign bit 14..11 binary exponent <code>b</code> 10..0 fraction <code>f</code> <p>The corresponding floating point value is computed by computing <code>f</code>/2048 * 2^(<code>b</code>-15). Note that this format is deliberately not IEEE-compliant; it's intended to be easy to decode by hand and not overwhelmingly sophisticated. However, it is similar to IEEE format in that it uses sign-magnitude rather than twos-complement for negative values.</p> <p>For example, if the data value is 0x8D, 0x55, the equivalent floating point number is found as follows.</p> <ol> <li>The full 16-bit number is 0x8D55.</li> <li>Bit 15 is 1, so this is a negative value.</li> <li><code>b</code> is 1, and <code>b</code>-15 is -14. 2^-14 is 1/16384</li> <li><code>f</code> is 0x555. 0x555/2048 = 1365/2048 is 0.667</li> <li><code>f * 2^(b-15)</code> is therefore 0.667/16384 or 0.00004068</li> <li>Since the number is negative, the value is -0.00004068</li> </ol> <p>Floating point mavens will immediately recognize:</p> <ul> <li>This format uses sign/magnitude representation for negative numbers.</li> <li>Numbers do not need to be normalized (although in practice they always are).</li> <li>The format is somewhat wasteful, because it explicitly transmits the most-significant bit of the fraction. (Most binary floating-point formats assume that <code>f</code> is is normalized, which means by definition that the exponent <code>b</code> is adjusted and <code>f</code> is shifted left until the most-significant bit of <code>f</code> is one. Most formats then choose to delete the most-significant bit from the encoding. If we were to do that, we would insist that the actual value of <code>f</code> be in the range 2048..4095, and then transmit only <code>f - 2048</code>, saving a bit. However, this complicates the handling of gradual underflow; see next point.)</li> <li>Gradual underflow at the bottom of the range is automatic and simple with this encoding; the more sophisticated schemes need extra logic (and extra testing) in order to provide the same feature.</li> </ul>"},{"location":"#javascript-decoder","title":"JavaScript decoder","text":"<pre><code>function sflt162f(rawSflt16) {\n// rawSflt16 is the 2-byte number decoded from wherever;\n// it's in range 0..0xFFFF\n// bit 15 is the sign bit\n// bits 14..11 are the exponent\n// bits 10..0 are the the mantissa. Unlike IEEE format,\n// the msb is explicit; this means that numbers\n// might not be normalized, but makes coding for\n// underflow easier.\n// As with IEEE format, negative zero is possible, so\n// we special-case that in hopes that JavaScript will\n// also cooperate.\n//\n// The result is a number in the open interval (-1.0, 1.0);\n//\n// throw away high bits for repeatability.\nrawSflt16 &amp;= 0xffff;\n// special case minus zero:\nif (rawSflt16 == 0x8000) return -0.0;\n// extract the sign.\nvar sSign = (rawSflt16 &amp; 0x8000) != 0 ? -1 : 1;\n// extract the exponent\nvar exp1 = (rawSflt16 &gt;&gt; 11) &amp; 0xf;\n// extract the \"mantissa\" (the fractional part)\nvar mant1 = (rawSflt16 &amp; 0x7ff) / 2048.0;\n// convert back to a floating point number. We hope\n// that Math.pow(2, k) is handled efficiently by\n// the JS interpreter! If this is time critical code,\n// you can replace by a suitable shift and divide.\nvar f_unscaled = sSign * mant1 * Math.pow(2, exp1 - 15);\nreturn f_unscaled;\n}\n</code></pre>"},{"location":"#uflt16","title":"uflt16","text":"<p>A <code>uflt16</code> datum represents an unsigned floating point number in the range [0, 1.0), transmitted as a 16-bit field. The encoded field is interpreted as follows:</p> bits description 15..12 binary exponent <code>b</code> 11..0 fraction <code>f</code> <p>The corresponding floating point value is computed by computing <code>f</code>/4096 * 2^(<code>b</code>-15). Note that this format is deliberately not IEEE-compliant; it's intended to be easy to decode by hand and not overwhelmingly sophisticated.</p> <p>For example, if the transmitted message contains 0xEB, 0xF7, and the transmitted byte order is big endian, the equivalent floating point number is found as follows.</p> <ol> <li>The full 16-bit number is 0xEBF7.</li> <li><code>b</code> is therefore 0xE, and <code>b</code>-15 is -1. 2^-1 is 1/2</li> <li><code>f</code> is 0xBF7. 0xBF7/4096 is 3063/4096 == 0.74780...</li> <li><code>f * 2^(b-15)</code> is therefore 0.74780/2 or 0.37390</li> </ol> <p>Floating point mavens will immediately recognize:</p> <ul> <li>There is no sign bit; all numbers are positive.</li> <li>Numbers do not need to be normalized (although in practice they always are).</li> <li>The format is somewhat wasteful, because it explicitly transmits the most-significant bit of the fraction. (Most binary floating-point formats assume that <code>f</code> is is normalized, which means by definition that the exponent <code>b</code> is adjusted and <code>f</code> is shifted left until the most-significant bit of <code>f</code> is one. Most formats then choose to delete the most-significant bit from the encoding. If we were to do that, we would insist that the actual value of <code>f</code> be in the range 4096..8191, and then transmit only <code>f - 4096</code>, saving a bit. However, this complicated the handling of gradual underflow; see next point.)</li> <li>Gradual underflow at the bottom of the range is automatic and simple with this encoding; the more sophisticated schemes need extra logic (and extra testing) in order to provide the same feature.</li> </ul>"},{"location":"#uflt16-javascript-decoder","title":"uflt16 JavaScript decoder","text":"<pre><code>function uflt162f(rawUflt16) {\n// rawUflt16 is the 2-byte number decoded from wherever;\n// it's in range 0..0xFFFF\n// bits 15..12 are the exponent\n// bits 11..0 are the the mantissa. Unlike IEEE format,\n// the msb is explicit; this means that numbers\n// might not be normalized, but makes coding for\n// underflow easier.\n// As with IEEE format, negative zero is possible, so\n// we special-case that in hopes that JavaScript will\n// also cooperate.\n//\n// The result is a number in the half-open interval [0, 1.0);\n//\n// throw away high bits for repeatability.\nrawUflt16 &amp;= 0xffff;\n// extract the exponent\nvar exp1 = (rawUflt16 &gt;&gt; 12) &amp; 0xf;\n// extract the \"mantissa\" (the fractional part)\nvar mant1 = (rawUflt16 &amp; 0xfff) / 4096.0;\n// convert back to a floating point number. We hope\n// that Math.pow(2, k) is handled efficiently by\n// the JS interpreter! If this is time critical code,\n// you can replace by a suitable shift and divide.\nvar f_unscaled = mant1 * Math.pow(2, exp1 - 15);\nreturn f_unscaled;\n}\n</code></pre>"},{"location":"#sflt12","title":"sflt12","text":"<p>A <code>sflt12</code> datum represents an signed floating point number in the range [0, 1.0), transmitted as a 12-bit field. The encoded field is interpreted as follows:</p> bits description 11 sign bit 11..8 binary exponent <code>b</code> 7..0 fraction <code>f</code> <p>The corresponding floating point value is computed by computing <code>f</code>/128 * 2^(<code>b</code>-15). Note that this format is deliberately not IEEE-compliant; it's intended to be easy to decode by hand and not overwhelmingly sophisticated.</p> <p>For example, if the transmitted message contains 0x8, 0xD5, the equivalent floating point number is found as follows.</p> <ol> <li>The full 16-bit number is 0x8D5.</li> <li>The number is negative.</li> <li><code>b</code> is 0x1, and <code>b</code>-15 is -14. 2^-14 is 1/16384</li> <li><code>f</code> is 0x55. 0x55/128 is 85/128, or 0.66</li> <li><code>f * 2^(b-15)</code> is therefore 0.66/16384 or 0.000041 (to two significant digits)</li> <li>The decoded number is therefore -0.000041.</li> </ol> <p>Floating point mavens will immediately recognize:</p> <ul> <li>This format uses sign/magnitude representation for negative numbers.</li> <li>Numbers do not need to be normalized (although in practice they always are).</li> <li>The format is somewhat wasteful, because it explicitly transmits the most-significant bit of the fraction. (Most binary floating-point formats assume that <code>f</code> is is normalized, which means by definition that the exponent <code>b</code> is adjusted and <code>f</code> is shifted left until the most-significant bit of <code>f</code> is one. Most formats then choose to delete the most-significant bit from the encoding. If we were to do that, we would insist that the actual value of <code>f</code> be in the range 128 .. 256, and then transmit only <code>f - 128</code>, saving a bit. However, this complicates the handling of gradual underflow; see next point.)</li> <li>Gradual underflow at the bottom of the range is automatic and simple with this encoding; the more sophisticated schemes need extra logic (and extra testing) in order to provide the same feature.</li> <li>It can be strongly argued that dropping the sign bit would be worth the effort, as this would get us 14% more resolution for a minor amount of work.</li> </ul>"},{"location":"#sflt12f-javascript-decoder","title":"sflt12f JavaScript decoder","text":"<pre><code>function sflt12f(rawSflt12) {\n// rawSflt12 is the 2-byte number decoded from wherever;\n// it's in range 0..0xFFF (12 bits). For safety, we mask\n// on entry and discard the high-order bits.\n// bit 11 is the sign bit\n// bits 10..7 are the exponent\n// bits 6..0 are the the mantissa. Unlike IEEE format,\n// the msb is explicit; this means that numbers\n// might not be normalized, but makes coding for\n// underflow easier.\n// As with IEEE format, negative zero is possible, so\n// we special-case that in hopes that JavaScript will\n// also cooperate.\n//\n// The result is a number in the open interval (-1.0, 1.0);\n//\n// throw away high bits for repeatability.\nrawSflt12 &amp;= 0xfff;\n// special case minus zero:\nif (rawSflt12 == 0x800) return -0.0;\n// extract the sign.\nvar sSign = (rawSflt12 &amp; 0x800) != 0 ? -1 : 1;\n// extract the exponent\nvar exp1 = (rawSflt12 &gt;&gt; 7) &amp; 0xf;\n// extract the \"mantissa\" (the fractional part)\nvar mant1 = (rawSflt12 &amp; 0x7f) / 128.0;\n// convert back to a floating point number. We hope\n// that Math.pow(2, k) is handled efficiently by\n// the JS interpreter! If this is time critical code,\n// you can replace by a suitable shift and divide.\nvar f_unscaled = sSign * mant1 * Math.pow(2, exp1 - 15);\nreturn f_unscaled;\n}\n</code></pre>"},{"location":"#uflt12","title":"uflt12","text":"<p>A <code>uflt12</code> datum represents an unsigned floating point number in the range [0, 1.0), transmitted as a 16-bit field. The encoded field is interpreted as follows:</p> bits description 11..8 binary exponent <code>b</code> 7..0 fraction <code>f</code> <p>The corresponding floating point value is computed by computing <code>f</code>/256 * 2^(<code>b</code>-15). Note that this format is deliberately not IEEE-compliant; it's intended to be easy to decode by hand and not overwhelmingly sophisticated.</p> <p>For example, if the transmitted message contains 0x1, 0xAB, the equivalent floating point number is found as follows.</p> <ol> <li>The full 16-bit number is 0x1AB.</li> <li><code>b</code> is therefore 0x1, and <code>b</code>-15 is -14. 2^-14 is 1/16384</li> <li><code>f</code> is 0xAB. 0xAB/256 is 0.67</li> <li><code>f * 2^(b-15)</code> is therefore 0.67/16384 or 0.0000408 (to three significant digits)</li> </ol> <p>Floating point mavens will immediately recognize:</p> <ul> <li>There is no sign bit; all numbers are positive.</li> <li>Numbers do not need to be normalized (although in practice they always are).</li> <li>The format is somewhat wasteful, because it explicitly transmits the most-significant bit of the fraction. (Most binary floating-point formats assume that <code>f</code> is is normalized, which means by definition that the exponent <code>b</code> is adjusted and <code>f</code> is shifted left until the most-significant bit of <code>f</code> is one. Most formats then choose to delete the most-significant bit from the encoding. If we were to do that, we would insist that the actual value of <code>f</code> be in the range 256 .. 512, and then transmit only <code>f - 256</code>, saving a bit. However, this complicates the handling of gradual underflow; see next point.)</li> <li>Gradual underflow at the bottom of the range is automatic and simple with this encoding; the more sophisticated schemes need extra logic (and extra testing) in order to provide the same feature.</li> </ul>"},{"location":"#uflt12f-javascript-decoder","title":"uflt12f JavaScript decoder","text":"<pre><code>function uflt12f(rawUflt12) {\n// rawUflt12 is the 2-byte number decoded from wherever;\n// it's in range 0..0xFFF (12 bits). For safety, we mask\n// on entry and discard the high-order bits.\n// bits 11..8 are the exponent\n// bits 7..0 are the the mantissa. Unlike IEEE format,\n// the msb is explicit; this means that numbers\n// might not be normalized, but makes coding for\n// underflow easier.\n// As with IEEE format, negative zero is possible, so\n// we special-case that in hopes that JavaScript will\n// also cooperate.\n//\n// The result is a number in the half-open interval [0, 1.0);\n//\n// throw away high bits for repeatability.\nrawUflt12 &amp;= 0xfff;\n// extract the exponent\nvar exp1 = (rawUflt12 &gt;&gt; 8) &amp; 0xf;\n// extract the \"mantissa\" (the fractional part)\nvar mant1 = (rawUflt12 &amp; 0xff) / 256.0;\n// convert back to a floating point number. We hope\n// that Math.pow(2, k) is handled efficiently by\n// the JS interpreter! If this is time critical code,\n// you can replace by a suitable shift and divide.\nvar f_unscaled = sSign * mant1 * Math.pow(2, exp1 - 15);\nreturn f_unscaled;\n}\n</code></pre>"},{"location":"#release-history","title":"Release History","text":"<ul> <li> <p>HEAD has the following changes.</p> </li> <li> <p>Enable device time request by default in config file (#840).</p> </li> <li> <p>v4.1.1 is a patch release.</p> </li> <li> <p>Fix US-like regions when network server disables all channels before setting others up (#819).</p> </li> <li>Fix US-like regions when network server disables all banks before setting others up (#820).</li> <li> <p>Documentation improvements in README and in code commentary.</p> </li> <li> <p>v4.1.0 contains the following changes</p> </li> <li> <p>Adapt <code>ttn-otaa-network-time</code> example to be compatible with PaulStoffregen/Time v1.6.1, which deletes <code>Time.h</code> in favor of <code>TimeLib.h</code> #763. Version is v4.0.1-pre1.</p> </li> <li>Add support for TTGO LoRa32-OLED v2.1.6. (Thanks to @ChrSchultz, #692.)</li> <li>Correct max TX EIRP for Japan to 13 dBm. (Thanks to @ryos36, #662.)</li> <li>Correct link in this document to the LMIC-v4.0.0 pdf (#788, thanks @lnlp).</li> <li>Warn about Feather pin wiring requirements (#755, thanks to @d-a-v).</li> <li>Fix typos in this document (#780, thanks @PeeJay).</li> <li>Fix additional warnings on non-ARM platforms (#791, thanks @d-a-v).</li> <li>Allow application to set the value to be used in <code>DeviceStatusAns</code> MAC messages (#576 and #560, thanks to @altishchenko).</li> <li>Minor adjustments to the compliance sketch (#800).</li> <li> <p>Update the LMIC reference manual to <code>LMIC-v4.1.0.pdf</code>.</p> </li> <li> <p>v4.0 is a major release; changes are significant enough to be \"likely breaking\". It includes the following changes.</p> </li> <li> <p>Fix some broken documentation references #644, #646, #673.</p> </li> <li>Re-added CI testing, since Travis CI no longer works for us #647; fixed AVR compliance CI compile #679.</li> <li>Don't use <code>defined()</code> in macro definitions #606</li> <li>Fix a warning on AVR32 #709.</li> <li>Fix Helium link in examples #715, #718.</li> <li>Remove <code>XCHANNEL</code> support from US region #404</li> <li>Assign channels randomly without replacement #515, #619, #730.</li> <li>Don't allow <code>LMIC_setupChannel()</code> to change default channels #722. Add <code>LMIC_queryNumDefaultChannels()</code> #700.</li> <li>Don't accept out-of-range DRs from MAC downlink messages #723</li> <li>Adopt semantic versions completely #726.</li> <li>Implement JoinAccept CFList processing for US/AU #739.</li> <li>Correct JoinAccept CFList processing for AS923 #740.</li> <li> <p>Don't compile board config objects when we know for sure they'll not be used; compilers can't always tell #736.</p> </li> <li> <p>v3.3.0 is primarily a maintenance and roll-up release.</p> </li> <li> <p>Added LoRaWAN-at-a-glance and a state diagram of the LMIC.</p> </li> <li>Several PRs from Matthijs Kooijman to improve compatibility with the original Arduino LMIC (#608, #609).</li> <li> <p>Numerous documentation improvements contributed by the community (#431, #612, #614, #625).</p> </li> <li> <p>v3.2.0 has the following changes:</p> </li> <li> <p>#550 fixes debug prints in <code>ttn-otaa.ino</code>.</p> </li> <li>#553 add full regional support to <code>raw.ino</code> and <code>ttn-abp.ino</code>.</li> <li>#570 corrects handling of piggy-back MAC responses when sending an <code>LMIC_sendAlive()</code> (<code>OPMODE_POLL</code>) message.</li> <li>#524 corrects handling of interrupt disable, and slightly refactors the low-level interrupt handling wrappers for clarity. With this change, <code>radio_irq_handler_v2()</code> is never called except from the run loop, and so the radio driver need not (and does not) disable interrupts. Version is v3.1.0.20.</li> <li>#568 improves documentation for the radio driver.</li> <li> <p>#537 fixes a compile error in SX1272 support. (Thanks @ricaun.) Version is v3.1.0.10.</p> </li> <li> <p>v3.1.0 officially adopts the changes from v3.0.99. There were dozens of changes; check the GitHub issue logs and change logs. This was a breaking release (due to changes in data layout in the LMIC structure; the structure is accessed by apps).</p> </li> <li> <p>v3.0.99 (the pre-release for v3.1.0) added the following changes. (This is not an exhaustive list.) Note that the behavior of the LMIC changes in important ways, as it now enforces the LoRaWAN mandated maximum frame size for a given data rate. For Class A devices, this may cause your device to go silent after join, if you're not able to handle the frame size dictated by the parameters downloaded to the device by the network during join. The library will attempt to find a data rate that will work, but there is no guarantee that the network has provided such a data rate.</p> </li> <li> <p>#470 corrects the name of AU915 region. #516 makes sure that <code>LMIC_REGION_au921</code> is defined (but deprecated) for backward compatibility.</p> </li> <li>#452 fixes a bug #450 in <code>LMIC_clrTxData()</code> that would cause join hiccups if called while (1) a join was in progress and (2) a regular data packet was waiting to be uplinked after the join completes. Also fixes AS923- and AU915-specific bugs #446, #447, #448. Version is <code>v3.0.99.5</code>.</li> <li>#443 addresses a number of problems found in cooperation with RedwoodComm. They suggested a timing improvement to speed testing; this lead to the discovery of a number of problems. Some were in the compliance framework, but one corrects timing for very high spreading factors, several (#442, #436, #435, #434 fix glaring problems in FSK support; #249 greatly enhances stability by making API calls much less likely to crash the LMIC if it's active. Version is v3.0.99.3.</li> <li>#388, #389, #390 change the LMIC to honor the maximum frame size for a given DR in the current region. This proves to be a breaking change for many applications, especially in the US, because DR0 in the US supports only an 11-byte payload, and many apps were ignoring this. Additional error codes were defined so that apps can detect and recover from this situation, but they must detect; otherwise they run the risk of being blocked from the network by the LMIC. Because of this change, the next version of the LMIC will be V3.1 or higher, and the LMIC version for development is bumped to 3.0.99.0.</li> <li>#401 adds 865 MHz through 868 MHz to the \"1%\" band for EU.</li> <li>#395 corrects pin-mode initialization if using <code>hal_interrupt_init()</code>.</li> <li>#385 corrects an error handling data rate selection for <code>TxParamSetupReq</code>, found in US-915 certification testing. (v2.3.2.71)</li> <li>#378 completely reworks MAC downlink handling. Resulting code passes the LoRaWAN V1.5 EU certification test. (v2.3.2.70)</li> <li> <p>#360 adds support for the KR-920 regional plan.</p> </li> <li> <p>v2.3.2 is a patch release. It incorporates two pull requests.</p> </li> <li> <p>#204 eliminates a warning if using a custom pin-map.</p> </li> <li> <p>#206 updates CI testing to Arduino IDE v1.8.8.</p> </li> <li> <p>v2.3.1 is a patch release. It adds <code>&lt;arduino_lmic_user_configuration.h&gt;</code>, which loads the pre-processor LMIC configuration variables into scope (issue #199).</p> </li> <li> <p>v2.3.0 introduces two important changes.</p> </li> <li> <p>The pin-map is extended with an additional field <code>pConfig</code>, pointing to a C++ class instance. This instance, if provided, has extra methods for dealing with TCXO control and other fine details of operating the radio. It also gives a natural way for us to extend the behavior of the HAL.</p> </li> <li> <p>Pinmaps can be pre-configured into the library, so that users don't have to do this in every sketch.</p> </li> </ul> <p>Accompanying this was a fairly large refactoring of inner header files. We now have top-level header file <code>&lt;arduino_lmic_hal_configuration.h&gt;</code>, which provides much the same info as the original <code>&lt;hal/hal.h&gt;</code>, without bringing most of the LMIC internal definitions into scope. We also changed the SPI API based on a suggestion from <code>@manuelbl</code>, making the HAL more friendly to structured BSPs (and also making the SPI API potentially faster).</p> <ul> <li> <p>Interim bug fixes: added a new API (<code>radio_irq_handler_v2()</code>), which allows the caller to provide the timestamp of the interrupt. This allows for more accurate timing, because the knowledge of interrupt overhead can be moved to a platform-specific layer (#148). Fixed compile issues on ESP32 (#140 and #153). We added ESP32 and 32u4 as targets in CI testing. We switched CI testing to Arduino IDE 1.8.7.   Fixed issue #161 selecting the Japan version of as923 using <code>CFG_as923jp</code> (selecting via <code>CFG_as923</code> and <code>LMIC_COUNTRY_CODE=LMIC_COUNTRY_CODE_JP</code> worked).   Fixed #38 -- now any call to hal_init() will put the NSS line in the idle (high/inactive) state. As a side effect, RXTX is initialized, and RESET code changed to set value before transitioning state. Likely no net effect, but certainly more correct.</p> </li> <li> <p>V2.2.2 adds <code>ttn-abp-feather-us915-dht22.ino</code> example, and fixes some documentation typos. It also fixes encoding of the <code>Margin</code> field of the <code>DevStatusAns</code> MAC message (#130). This makes Arduino LMIC work with networks implemented with LoraServer.</p> </li> <li> <p>V2.2.1 corrects the value of <code>ARDUINO_LMIC_VERSION</code> (#123), allows ttn-otaa-feather-us915 example to compile for the Feather 32u4 LoRa (#116), and addresses documentation issues (#122, #120).</p> </li> <li> <p>V2.2.0 adds encoding functions and <code>tn-otaa-feather-us915-dht22.ino</code> example. Plus a large number of issues: #59, #60, #63, #64 (listen-before-talk for Japan), #65, #68, #75, #78, #80, #91, #98, #101. Added full Travis CI testing, switched to travis-ci.com as the CI service. Prepared to publish library in the official Arduino library list.</p> </li> <li> <p>V2.1.5 fixes issue #56 (a documentation bug). Documentation was quickly reviewed and other issues were corrected. The OTAA examples were also updated slightly.</p> </li> <li> <p>V2.1.4 fixes issues #47 and #50 in the radio driver for the SX1276 (both related to handling of output power control bits).</p> </li> <li> <p>V2.1.3 has a fix for issue #43: handling of <code>LinkAdrRequest</code> was incorrect for US915 and AU915; when TTN added ADR support on US and AU, the deficiency was revealed (and caused an ASSERT).</p> </li> <li> <p>V2.1.2 has a fix for issue #39 (adding a prototype for <code>LMIC_DEBUG_PRINTF</code> if needed). Fully upward compatible, so just a patch.</p> </li> <li> <p>V2.1.1 has the same content as V2.1.2, but was accidentally released without updating <code>library.properties</code>.</p> </li> <li> <p>V2.1.0 adds support for the Murata LoRaWAN module.</p> </li> <li> <p>V2.0.2 adds support for additional regions.</p> </li> </ul>"},{"location":"#contributions","title":"Contributions","text":"<p>This library started from the IBM V1.5 open-source code.</p> <ul> <li> <p>Thomas Telkamp and Matthijs Kooijman ported V1.5 to Arduino and did a lot of bug fixing.</p> </li> <li> <p>Terry Moore, LeRoy Leslie, Frank Rose, and ChaeHee Won did a lot of work on US support.</p> </li> <li> <p>Terry Moore added the AU915, AS923, KR920 and IN866 regions, and created the regionalization framework, and did corrections for LoRaWAN 1.0.3 compliance testing.</p> </li> <li> <p><code>@tanupoo</code> of the WIDE Project debugged AS923JP and LBT support.</p> </li> <li> <p><code>@frazar</code> contributed numerous features, e.g. network time support, CI testing, documentation improvements.</p> </li> <li> <p><code>@manuelbl</code> contributed numerous ESP32-related patches and improvements.</p> </li> <li> <p><code>@ngraziano</code> did extensive testing and contributed numerous ADR-related patches.</p> </li> </ul> <p>There are many others, who have contributed code and also participated in discussions, performed testing, reported problems and results. Thanks to all who have participated. We hope to use something like All Contributors to help keep this up to date, but so far the automation isn't working.</p>"},{"location":"#trademark-acknowledgements","title":"Trademark Acknowledgements","text":"<p>LoRa is a registered trademark of Semtech Corporation. LoRaWAN is a registered trademark of the LoRa Alliance.</p> <p>MCCI and MCCI Catena are registered trademarks of MCCI Corporation.</p> <p>All other trademarks are the properties of their respective owners.</p>"},{"location":"#license","title":"License","text":"<p>The upstream files from IBM v1.6 are based on the Berkeley license, and the merge which synchronized this repository therefore migrated the core files to the Berkeley license. However, modifications made in the Arduino branch were done under the Eclipse license, so the overall license of this repository is still Eclipse Public License v1.0. The examples which use a more liberal license. Some of the AES code is available under the LGPL. Refer to each individual source file for more details, but bear in mind that until the upstream developers look into this issue, it is safest to assume the Eclipse license applies.</p>"},{"location":"#support-open-source-hardware-and-software","title":"Support Open Source Hardware and Software","text":"<p>MCCI invests time and resources providing this open source code, please support MCCI and open-source hardware by purchasing products from MCCI, Adafruit and other open-source hardware/software vendors!</p> <p>For information about MCCI's products, please visit store.mcci.com.</p>"},{"location":"howto-add-region/","title":"Adding a new region to Arduino LMIC","text":"<p>This variant of the Arduino LMIC code supports adding additional regions beyond the eu868 and us915 bands supported by the original IBM LMIC 1.6 code.</p> <p>This document outlines how to add a new region.</p>"},{"location":"howto-add-region/#planning","title":"Planning","text":""},{"location":"howto-add-region/#determine-the-regionregion-category","title":"Determine the region/region category","text":"<p>Compare the target region (in the LoRaWAN regional specification) to the EU868 and US915 regions. There are three possibilities.</p> <ol> <li> <p>The region is like the EU region. There are a limited number of channels (up to 8), and only a small number of channels are used for OTAA join operations. The response masks refer to individual channels, and the JOIN-response can send frequencies of specific channels to be added.</p> </li> <li> <p>The region is like the US region. There are many channels (the US has 64) with fixed frequencies, and the channel masks refer to subsets of the fixed channels.</p> </li> <li> <p>The region is not really like either the EU or US. At the moment, it seems that CN470-510MHz (section 2.6 of LoRaWAN Regional Parameters spec V1.0.2rB) falls into this category.</p> </li> </ol> <p>Band plans in categories (1) and (2) are easily supported. Band plans in category (3) are not supported by the current code.</p>"},{"location":"howto-add-region/#check-whether-the-region-is-already-listed-in-lmic_config_preconditionsh","title":"Check whether the region is already listed in <code>lmic_config_preconditions.h</code>","text":"<p>Check <code>src/lmic/lmic_config_preconditions.h</code> and scan the <code>LMIC_REGION_...</code> definitions. The numeric values are assigned based on the subchapter in section 2 of the LoRaWAN 1.0.2 Regional Parameters document. If your symbol is already there, then the first part of adaptation has already been done. There will already be a corresponding <code>CFG_...</code> symbol. But if your region isn't supported, you'll need to add it here.</p> <ul> <li><code>LMIC_REGION_myregion</code> must be a distinct integer, and must be less than 32 (so as to fit into a bitmask)</li> </ul>"},{"location":"howto-add-region/#make-the-appropriate-changes-in-lmic_config_preconditionsh","title":"Make the appropriate changes in <code>lmic_config_preconditions.h</code>","text":"<ul> <li><code>LMIC_REGION_SUPPORTED</code> is a bit mask of all regions supported by the code. Your new region must appear in this list.</li> <li><code>CFG_LMIC_REGION_MASK</code> is a bit mask that, when expanded, returns a bitmask for each defined <code>CFG_...</code> variable. You must add your <code>CFG_myregion</code> symbol to this list.</li> <li><code>CFG_region</code> evaluates to the <code>LMIC_REGION_...</code> value for the selected region (as long as only one region is selected). The header files check for this, so you don't have to.</li> <li><code>CFG_LMIC_EU_like_MASK</code> is a bitmask of regions that are EU-like, and <code>CFG_LMIC_US_like_MASK</code> is a bitmask of regions that are US-like. Add your region to the appropriate one of these two variables.</li> </ul>"},{"location":"howto-add-region/#document-your-region-in-readmemd","title":"Document your region in <code>README.md</code>","text":"<p>You'll see where the regions are listed. Add yours.</p>"},{"location":"howto-add-region/#add-the-definitions-for-your-region-in-lorabaseh","title":"Add the definitions for your region in <code>lorabase.h</code>","text":"<ul> <li>If your region is EU like, copy the EU block. Document any duty-cycle limitations.</li> <li>if your region is US like, copy the US block.</li> <li>As appropriate, copy <code>lorabase_eu868.h</code> or <code>lorabase_us915.h</code> to make your own <code>lorabase_newregion.h</code>. Fill in the symbols.</li> </ul> <p>At time of writing, you need to duplicate some code to copy some settings from <code>lorabase_eu868.h</code> or <code>lorabase_us915.h</code> to the new file; and you need to put some region-specific knowledge into the <code>lorabase.h</code> header file. The long-term direction is to put all the regional knowledge into the region-specific header, and then the central code will just copy. The architectural impulse is that we'll want to be able to reuse the regional header files in other contexts. On the other hand, because it's error prone, we don't want to <code>#include</code> files that aren't being used; otherwise you could accidentally use EU parameters in US code, etc.</p> <ul> <li>Now's a good time to test-compile and clean out errors introduced. Make sure you set the region to your new target region. You'll have problems compiling, but they should look like this:</li> </ul> <pre><code>lmic.c:29: In file included from\nlmic_bandplan.h: 52:3: error: #error \"LMICbandplan_maxFrameLen() not defined by bandplan\"\n    # error \"LMICbandplan_maxFrameLen() not defined by bandplan\"\nlmic_bandplan.h: 56:3: error: #error \"pow2dBm() not defined by bandplan\"\n    # error \"pow2dBm() not defined by bandplan\"\n</code></pre> <ul> <li> <p>If using an MCCI BSP, you might want to edit your local copy of <code>boards.txt</code> to add the new region.</p> </li> <li> <p>If using an MCCI BSP, you should definitely edit the template files to add the new region to the list.</p> </li> <li> <p>Modify the <code>.travis.yml</code> file to test the new region.</p> </li> </ul>"},{"location":"howto-add-region/#edit-lmic_bandplanh","title":"Edit <code>lmic_bandplan.h</code>","text":"<p>The next step is to add the region-specific interfaces for your region.</p> <p>Do this by editing <code>lmic_bandplan.h</code> and adding the appropriate call to a (new) region-specific file <code>lmic_bandplan_myregion.h</code>, where \"myregion\" is the abbreviation for your region.</p> <p>Then, if your region is eu868-like, copy <code>lmic_bandplan_eu868.h</code> to create your new region-specific header file; otherwise copy <code>lmic_bandplan_us915.h</code>.</p> <p>Edit the file.</p> <p>Try to compile again; you should now get link errors related to your new band-plan, like this:</p> <pre><code>c:\\tmp\\buildfolder\\libraries\\arduino-lmic\\lmic\\lmic.c.o: In function `lowerDR':\nC:\\Users\\tmm\\Documents\\Arduino\\libraries\\arduino-lmic\\src\\lmic/lorabase.h:667: undefined reference to `constant_table__DR2RPS_CRC'\n</code></pre>"},{"location":"howto-add-region/#create-lmic_newregionc","title":"Create <code>lmic_newregion.c</code>","text":"<p>Once again, you will start by copying either <code>lmic_eu868.c</code> or <code>lmic_us915.c</code> to create your new file. Then touch it up as necessary.</p>"},{"location":"howto-add-region/#general-discussion","title":"General Discussion","text":"<ul> <li> <p>You'll find it easier to do the test compiles using the example scripts in this directory, rather than trying to get all the Catena framework going too. On the other hand, working with the Catena framework will expose more problems.</p> </li> <li> <p>Don't forget to check and update the examples.</p> </li> <li> <p>You will also need to update the <code>boards.template</code> file for MCCI BSPs, in order to get the region to show up in the Arduino IDE menu.</p> </li> <li> <p>You will need to update the <code>arduino-lorawan</code> library to include support for the new region. (See below for instructions.)</p> </li> <li> <p>Please increase the version of <code>arduino-lmic</code> (symbol <code>ARDUINO_LMIC_VERSION</code> in <code>src/lmic/lmic.h</code>), and change <code>arduino-lorawan</code>'s <code>Arduino_LoRaWAN_lmic.h</code> to check for at least that newer version.</p> </li> <li> <p>Please also increase the version of the <code>arduino-lorawan</code> library (symbol <code>ARDUINO_LORAWAN_VERSION</code>).</p> </li> </ul>"},{"location":"howto-add-region/#adding-the-region-to-the-arduino_lorawan-library","title":"Adding the region to the Arduino_LoRaWAN library","text":"<p>In <code>Arduino_LoRaWAN_ttn.h</code>:</p> <ul> <li>Add a new class with name <code>Arduino_LoRaWAN_ttn_myregion</code>, copied either from the <code>Arduino_LoRaWAN_ttn_eu868</code> class or the <code>Arduino_LoRaWAN_ttn_us915</code> class.</li> <li>Extend the list of <code>#if defined(CFG_eu868)</code> etc. to define <code>Arduino_LoRaWAN_REGION_TAG</code> to the suffix of your new class if <code>CFG_myregion</code> is defined.</li> </ul> <p>Then copy and edit either <code>ttn_eu868_netbegin.cpp</code>/<code>ttn_eu868_netjoin.cpp</code> or <code>ttn_us915_netbegin.cpp</code>/<code>ttn_us915_netjoin.cpp</code> to make your own file(s) for the key functions.</p>"},{"location":"technical-specification/","title":"LMIC Product Information","text":"<p>The LMIC library was originally developed and marketed by the IBM Zurich Research Laboratory (IBM Research GmbH), 8803 R\u00fcschlikon, Switzerland. For additional information please contact: lrsc@zurich.ibm.com. This document was taken from V1.6, from July 2016.</p> <p>The library was adapted for Arduino by Mathijs Kooijman and Thomas Telkamp. This version of the document describes the version being maintained by MCCI Corporation at https://github.com/mcci-catena/arduino-lmic/.</p> <p>\u00a9 2018-2021 MCCI Corporation</p> <p>Copyright MCCI Corporation, 2018-2021. All rights reserved. Distributed under the terms of the LICENSE file found at https://github.com/mcci-catena/arduino-lmic/blob/master/LICENSE.</p> <p>\u00a9 2014-2016 IBM Corporation</p> <p>Copyright International Business Machines Corporation, 2014-2016. All Rights Reserved.</p> <p>The following are trademarks or registered trademarks of International Business Machines Corporation in the United States, or other countries, or both: IBM, the IBM Logo, Ready for IBM Technology.</p> <p>MCCI and MCCI Catena are registered trademarks of MCCI Corporation.</p> <p>LoRa is a registered trademark of Semtech Corporation.</p> <p>LoRaWAN is a registered trademark of the LoRa Alliance.</p> <p>Other company, product and service names may be trademarks or service marks of others.</p> <p>All information contained in this document is subject to change without notice. The information contained in this document does not affect or change IBM product specifications or warranties. Nothing in this document shall operate as an express or implied license or indemnity under the intellectual property rights of IBM or third parties. All information contained in this document was obtained in specific environments, and is presented as an illustration. The results obtained in other operating environments may vary. THE INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED ON AN \"AS IS\" BASIS. In no event will IBM be liable for damages arising directly or indirectly from any use of the information contained in this document.</p>"},{"location":"technical-specification/examples/","title":"Examples","text":"<p>A set of examples is provided to demonstrate how typical node applications can be implemented with only a few lines of code using the LMIC library.</p>"},{"location":"technical-specification/hal/","title":"Hardware Abstraction Layer","text":"<p>The LMIC library is separated into a large portion of portable code and a small platform-specific part. By implementing the functions of this hardware abstraction layer with the specified semantics, the library can be easily ported to new hardware platforms.</p>"},{"location":"technical-specification/hal/#hal-interface","title":"HAL Interface","text":"<p>The following groups of hardware components must be supported:</p> <ul> <li> <p>Up to four digital I/O lines are needed in output mode to drive the radio\u2019s antenna switch (<code>RX</code> and <code>TX</code>), the SPI chip select (<code>NSS</code>), and the reset line (<code>RST</code>).</p> </li> <li> <p>Three digital I/O lines are needed in input mode to sense the radio\u2019s transmitter and receiver states (<code>DIO0</code>, <code>DIO1</code> and <code>DIO2</code>).</p> </li> <li> <p>A SPI unit is needed to read and write the radio\u2019s registers.</p> </li> <li> <p>A timer unit is needed to precisely record events and to schedule new protocol actions.</p> </li> <li> <p>An interrupt controller cab be used to forward interrupts generated by the digital input lines.</p> </li> </ul> <p>This section describes the function interface required to access these hardware components:</p>"},{"location":"technical-specification/hal/#void-hal_init","title":"<code>void hal_init ()</code>","text":"<p>Initialize the hardware abstraction layer. Configure all components (IO, SPI, TIMER, IRQ) for further use with the <code>hal_xxx()</code> functions. This function is deprecated and obsolete. The LMIC library calls <code>hal_init_ex()</code> instead. The client cannot call <code>hal_init()</code> or <code>hal_init_ex()</code> directly,as they are called from <code>os_init()</code>/<code>os_init_ex()</code>, and they must only be called once.</p>"},{"location":"technical-specification/hal/#void-hal_init_ex-const-void-phaldata","title":"<code>void hal_init_ex (const void *pHalData)</code>","text":"<p>Initialize the hardware abstraction layer. Configure all components (IO, SPI, TIMER, IRQ) for further use with the <code>hal_xxx()</code> functions. pHalData is a pointer to HAL-specific data. When running with the Arduino HAL, this must be a pointer to a <code>lmic_pinmap</code> structure. The LMIC library calls <code>hal_init_ex()</code>. The client cannot call <code>hal_init()</code> or <code>hal_init_ex()</code> directly, as they are called from <code>os_init()</code>/<code>os_init_ex()</code>, and they must only be called once.</p>"},{"location":"technical-specification/hal/#void-hal_failed","title":"<code>void hal_failed ()</code>","text":"<p>Perform \u201cfatal failure\u201d action. This function will be called by code assertions on fatal conditions. Possible actions could be HALT or reboot.</p>"},{"location":"technical-specification/hal/#void-hal_pin_rxtx-u1_t-val","title":"<code>void hal_pin_rxtx (u1_t val)</code>","text":"<p>Drive the digital output pins RX and TX (0=receive, 1=transmit).</p>"},{"location":"technical-specification/hal/#void-hal_pin_rst-u1_t-val","title":"<code>void hal_pin_rst (u1_t val)</code>","text":"<p>Control the radio RST pin (0=low, 1=high, 2=floating)</p>"},{"location":"technical-specification/hal/#void-radio_irq_handler-u1_t-dio","title":"<code>void radio_irq_handler (u1_t dio)</code>","text":"<p>When the HAL detects a rising edge on any of the three input lines <code>DIO0</code>, <code>DIO1</code> and <code>DIO2</code>, it must notify the LMIC. It may do this by calling the function <code>radio_irq_handler()</code>. It must set dio to indicate the line which generated the interrupt (<code>0</code>, <code>1</code>, <code>2</code>). This routine is a wrapper for <code>radio_irq_handler_v2()</code>, and just calls <code>os_getTime()</code> to get the current time. If your hardware can capture the interrupt time more accurately, your HAL should use <code>radio_irq_handler_v2()</code>.</p>"},{"location":"technical-specification/hal/#void-radio_irq_handler_v2-u1_t-dio-os_time_t-tirq","title":"<code>void radio_irq_handler_v2 (u1_t dio, os_time_t tIrq)</code>","text":"<p>When the HAL detects a rising edge on any of the three input lines <code>DIO0</code>, <code>DIO1</code> and <code>DIO2</code>, it must notify the LMIC. If the HAL has a high-accuracy time-stamp for when the line changed state, it should call the function <code>radio_irq_handler_v2()</code>. Set <code>dio</code> to indicate the line which changed (<code>0</code>, <code>1</code>, <code>2</code>). Set <code>tIrq</code> to the time-stamp of when the line changed state.</p>"},{"location":"technical-specification/hal/#void-hal_spi_readu1_t-cmd-u1_t-buf-size_t-len","title":"<code>void hal_spi_read(u1_t cmd, u1_t* buf, size_t len)</code>","text":"<p>Perform a SPI read. Write the command byte <code>cmd</code>, then read <code>len</code> bytes into the buffer starting at buf.</p>"},{"location":"technical-specification/hal/#void-hal_spi_writeu1_t-cmd-const-u1_t-buf-size_t-len","title":"<code>void hal_spi_write(u1_t cmd, const u1_t* buf, size_t len)</code>","text":"<p>Perform a SPI write. Write the command byte <code>cmd</code>, followed <code>len</code> bytes from buffer starting at <code>buf</code>.</p>"},{"location":"technical-specification/hal/#u4_t-hal_ticks","title":"<code>u4_t hal_ticks ()</code>","text":"<p>Return 32-bit system time in ticks (same units as <code>ostime_t</code>) \u2013 but note that this is unsigned, whereas <code>ostime_t</code> is signed.</p>"},{"location":"technical-specification/hal/#void-hal_waituntil-u4_t-time","title":"<code>void hal_waitUntil (u4_t time)</code>","text":"<p>Busy-wait until specified timestamp (in ticks) is reached.</p>"},{"location":"technical-specification/hal/#u1_t-hal_checktimer-u4_t-targettime","title":"<code>u1_t hal_checkTimer (u4_t targettime)</code>","text":"<p>Check and rewind timer for given <code>targettime</code>. Return 1 if <code>targettime</code> is close (not worthwhile programming the timer). Otherwise rewind timer for exact <code>targettime</code> or for full timer period and return 0. The only action required when <code>targettime</code> is reached is that the CPU wakes up from possible sleep states.</p>"},{"location":"technical-specification/hal/#void-hal_disableirqs","title":"<code>void hal_disableIRQs ()</code>","text":"<p>Disable all CPU interrupts. Might be invoked nested. But will always be followed by matching call to <code>hal_enableIRQs()</code>.</p>"},{"location":"technical-specification/hal/#void-hal_enableirqs","title":"<code>void hal_enableIRQs ()</code>","text":"<p>Enable CPU interrupts. When invoked nested, only the outmost invocation actually must enable the interrupts.</p>"},{"location":"technical-specification/hal/#void-hal_sleep","title":"<code>void hal_sleep ()</code>","text":"<p>Sleep until interrupt occurs. Preferably system components can be put in low-power mode before sleep, and be re-initialized after sleep. When using the Arduino reference implementation, this is a no-op; the LMIC returns to the caller, who is responsible for arranging to sleep.</p>"},{"location":"technical-specification/hal/#s1_t-hal_getrssical","title":"<code>s1_t hal_getRssiCal ()</code>","text":"<p>Get the RSSI calibration for the radio, in dB. The radio driver adds this to the indicated RSSI to convert to absolute dB, for doing listen-before-talk computations. Not used unless listen-before-talk is configured for this region.</p>"},{"location":"technical-specification/hal/#ostime_t-hal_setmodulepower-bool-val","title":"<code>ostime_t hal_setModulePower (bool val)</code>","text":"<p>Request that the module be powered up or down. If true, TCXO power should be activated, and any normally high-Z control lines should be activated. This function returns the number of ticks of delay that must be inserted before using the radio. If module-level power control is not implemented, or if the radio is already in the desired state, this routine can just return zero. Normally a delay of a few milliseconds is needed when turning power on, but no delay is needed if power is already on or if turning power off.</p>"},{"location":"technical-specification/hal/#hal-reference-implementation-for-arduino","title":"HAL Reference Implementation for Arduino","text":"<p>The Arduino LMIC library includes a reference implementation of the HAL for the Arduino. Please refer to README.md for information about the implementation.</p>"},{"location":"technical-specification/introduction/","title":"Introduction","text":"<p>The Arduino IBM LoRaWAN C-library (LMIC) is a portable implementation of the LoRaWAN\u2122 1.0.3 end-device specification in the C programming language. (\u201cLMIC\u201d stands for \u201cLoRaWAN MAC in C\u201d). It supports the EU-868, US-915, AU-915, AS-923, KR-920 and IN-866 variants of the specification and it can handle class A and class B devices. The library takes care of all logical MAC states and timing constraints and drives the SEMTECH SX1272 or SX1276 radio. This way, applications are free to perform other tasks and the protocol compliance is guaranteed by the library. In order to ensure compliance with the specification and associated regulations, the state engine has been tested and verified using a logic simulation environment. The library has been carefully engineered to precisely satisfy the timing constraints of the MAC protocol and to even consider possible clock drifts in the timing computations. Applications can access and configure all functionality via a simple event-based programming model and do not have to deal with platform-specific details like interrupt handlers. By using a thin hardware abstraction layer (HAL), the library can be easily ported to new hardware platforms. An Arduino HAL is provided which allows for easy integration with most Arduino variants. Eight-bit AVR platforms are supported as well as 32-bit platforms.</p> <p>In addition to the provided LMIC library, a real-world application also needs drivers for the sensors or other hardware it desires to control. These application drivers are outside the scope of this document and are not part of this library.</p> <p> </p> High-level view of all application device components."},{"location":"technical-specification/introduction/#lorawan-versions-and-features-supported","title":"LoRaWAN Versions and Features Supported","text":"<p>The LMIC library supports Class A operation as described by the LoRaWAN specification V1.0.3 and V1.0.2. It does not support V1.1.</p> <p>Class B support code is provided, but is not tested.</p> <p>LoRaWAN 1.0.3 Class A multicast downlinks are not supported.</p> <p>Class C operation is not supported.</p> <p>The library has been tested for compliance with the following LoRaWAN 1.0.2 test specifications as implemented by RedwoodComm in their RWC5020A tester, using firmware version 1.170. The MCCI Catena 4610 was used as the reference device.</p> <ul> <li> <p>EU868 V1.5 (excluding optional data rates)</p> </li> <li> <p>US915 V1.3 (excluding optional data rates; testing was done using channels 0~7 and 64). The TxPower test fails because the LMIC complies with LoRaWAN V1.0.3. The TxPower test uses a value that is defined for V1.0.3, but not for V1.0.2, and expects the device to reject the value.</p> </li> <li> <p>AS923 V1.1 (excluding optional data rates)</p> </li> <li> <p>KR920 V1.2</p> </li> <li> <p>IN865 V1.0</p> </li> </ul> <p>All tests were performed using a tethered connection.</p>"},{"location":"technical-specification/introduction/#class-a-and-class-b-support","title":"Class A and Class B Support","text":"<p>The Arduino LMIC library can be configured to support LoRaWAN Class A and Class B operation. A Class A device receives only at fixed times after transmitting a message. This allows for low power operation, but means that downlink latency is controlled by how often the device transmits. A Class B device synchronizes to beacons transmitted by the network, and listens for messages at certain intervals (\u201cping slots\u201d) during the interval between beacons.</p> <p>Devices (and the LMIC library) start out as Class A devices, and switch to Class B based on requests from the application layer of the device.</p> <p>This document uses the term \u201cpinging\u201d to mean that the LMIC is operating in Class B and also listening for downlink during ping slots. If a device is pinging, then the LMIC must also be tracking the beacon. It is possible to track the beacon (perhaps for time synchronization purposes) without enabling pinging.</p> <p>Since many devices and networks only support Class A operation, the library can be configured at compile time to omit support for tracking and pinging. It is possible to omit support for pinging without omitting support for tracking, but this is not a tested configuration.</p>"},{"location":"technical-specification/programming-model-and-api/","title":"Programming Model and API","text":"<p>The LMIC library can be accessed via a set of API functions, run-time functions, callback functions, and a global LMIC data structure. The interface is defined in a single header file \u201c<code>lmic.h</code>\u201d which all applications should include.</p> <pre><code>#include \"lmic.h\"\n</code></pre> <p>The library version follows Semantic Versioning 2.0.0 (https://semver.org/). A single symbol represents the version. Bits 31..24 represent the major version, bits 23..15 the minor version, and bits 15..8 represent the patch. Bits 7..0 are used for representing the pre-release, called \u201cLOCAL\u201d for historical reasons.</p> <p>A function-like macro, <code>ARDUINO_LMIC_VERSION_CALC()</code>, is used to construct version numbers.</p> <pre><code>#define ARDUINO_LMIC_VERSION ARDUINO_LMIC_VERSION_CALC(2, 3, 2, 0)\n</code></pre> <p>For convenience, the library supplies function-like macros <code>ARDUINO_LMIC_VERSION_GET_MAJOR()</code>, <code>ARDUINO_LMIC_VERSION_GET_MINOR()</code>, <code>ARDUINO_LMIC_VERSION_GET_PATCH()</code>, and <code>ARDUINO_LMIC_\u00adVERSION_\u00adGET_LOCAL()</code>, which extract the appropriate field from a version number.</p> <p>Version numbers are represented naively \u2013 the four fields are simply packed together into a 32-bit word. This makes them easy to display, but hard to compare. Pre-releases are numbered higher than releases, but compare less. Several macros are provided to make it easy to compare versions numbers. <code>ARDUINO_LMIC_VERSION_TO_ORDINAL()</code> converts a version number computed by <code>ARDUINO_LMIC_VERSION_CALC()</code> into an integer that can be compared using the normal C comparison operators. <code>ARDUINO_LMIC_VERSION_COMPARE_LT(v1, v2)</code> compares two version numbers and returns non-zero if v1 is less than v2 (after converting both to ordinals). <code>ARDUINO_LMIC_VERSION_COMPARE_LE(v1, v2)</code>, <code>ARDUINO_LMIC_VERSION_COMPARE_GT(v1, v2)</code>, and <code>ARDUINO_LMIC_VERSION_COMPARE_GE(v1, v2)</code> test for less-than-or-equal, greater-than, or greater-than-or-equal relationships.</p> <p>To identify the original version of the IBM LMIC library two constants are defined in this header file.</p> <pre><code>#define LMIC_VERSION_MAJOR 1\n#define LMIC_VERSION_MINOR 6\n</code></pre> <p>These version strings identify the base version of the library, and will not change.</p>"},{"location":"technical-specification/programming-model-and-api/#programming-model","title":"Programming Model","text":"<p>The LMIC library offers a simple event-based programming model where all protocol events are dispatched to the application\u2019s <code>onEvent()</code> callback function (see 2.3.4). In order to free the application of details like timings or interrupts, the library has a built-in run-time environment to take care of timer queues and job management.</p>"},{"location":"technical-specification/programming-model-and-api/#application-jobs","title":"Application jobs","text":"<p>In this model all application code is run in so-called jobs which are executed on the main thread by the run-time scheduler function <code>os_runloop()</code> (see 2.2.6). These application jobs are coded as normal C functions and can be managed using the run-time functions described in section 2.1.3. For the job management an additional per job control struct <code>osjob_t</code> is required which identifies the job and stores context information. Jobs must not be long-running in order to ensure seamless operation! They should only update state and schedule actions, which will trigger new job or event callbacks.</p>"},{"location":"technical-specification/programming-model-and-api/#main-event-loop","title":"Main event loop","text":"<p>All an application must do is to initialize the run-time environment using the <code>os_init()</code> or <code>os_init_ex()</code> function and then periodically call the job scheduler function <code>os_runloop_once()</code>. In order to bootstrap protocol actions and generate events, an initial job needs to be set up. Therefore, a startup job is scheduled using the <code>os_setCallback()</code> function.</p> <pre><code>osjob_t initjob;\nvoid setup () {\n// initialize run-time env\nos_init();\n// setup initial job\nos_setCallback(&amp;initjob, initfunc);\n}\nvoid loop () {\n// execute scheduled jobs and events\nos_runloop_once();\n}\n</code></pre> <p>The startup code shown in the <code>initfunc()</code> function below initializes the MAC and starts joining the network.</p> <pre><code>// initial job\nstatic void initfunc (osjob_t* j) {\n// reset MAC state\nLMIC_reset();\n// start joining\nLMIC_startJoining();\n// init done - onEvent() callback will be invoked...\n}\n</code></pre> <p>The <code>initfunc()</code> function will return immediately, and the <code>onEvent()</code> callback function will be invoked by the scheduler later on for the events <code>EV_JOINING</code>, <code>EV_JOINED</code> or <code>EV_JOIN_FAILED</code>.</p>"},{"location":"technical-specification/programming-model-and-api/#os-time","title":"OS time","text":"<p>The LMIC uses values of the type <code>ostime_t</code> to represent time in ticks. The rate of these ticks defaults to 32768 ticks per second, but may be configured at compile time to any value between 10000 ticks per second and 64516 ticks per second.</p> <p>In general, one tick is not an integral number of microseconds or milliseconds. Convenience functions are provided for switching back and forth.</p> <pre><code>typedef int32_t ostime_t;\n</code></pre> <p>Note that this is a signed integer value; care must be taken when computing differences to avoid being fooled by overflow. OS time starts at zero, and increments uniformly to <code>INT32_MAX</code>; it then wraps to <code>INT32_MIN</code> and increments uniformly up to zero, and repeats. Rather than comparing two <code>ostime_t</code> values, recommended practice is to subtract them and see if the result is positive or negative.</p>"},{"location":"technical-specification/programming-model-and-api/#run-time-functions","title":"Run-time Functions","text":"<p>The run-time functions mentioned before are used to control the run-time environment. This includes initialization, scheduling and execution of the run-time jobs.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_init","title":"<code>void os_init ()</code>","text":"<p>Initialize the operating system by calling <code>os_init_ex(NULL)</code>.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_init_ex-const-void-phaldata","title":"<code>void os_init_ex (const void* pHalData)</code>","text":"<p>To facilitate use of this library on multiple platforms, the <code>os_init_ex()</code> routine takes an arbitrary pointer to platform data. The Arduino LMIC default HAL implementation expects this pointer to be a reference to a C++ <code>struct lmic_pinmap</code> object. See README.md for more information.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_setcallback-osjob_t-job-osjobcb_t-cb","title":"<code>void os_setCallback (osjob_t* job, osjobcb_t cb)</code>","text":"<p>Prepare an immediately runnable job. This function can be called at any time, including from interrupt handler contexts (e.g. if a new sensor value has become available).</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_settimedcallback-osjob_t-job-ostime_t-time-osjobcb_t-cb","title":"<code>void os_setTimedCallback (osjob_t* job, ostime_t time, osjobcb_t cb)</code>","text":"<p>Schedule a timed job to run at the given timestamp (absolute system time). This function can be called at any time, including from interrupt handler contexts.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_clearcallback-osjob_t-job","title":"<code>void os_clearCallback (osjob_t* job)</code>","text":"<p>Cancel a run-time job. A previously scheduled run-time job is removed from timer and run queues. The job is identified by the address of the job struct. The function has no effect if the specified job is not yet scheduled.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_runloop","title":"<code>void os_runloop ()</code>","text":"<p>Execute run-time jobs from the timer and from the run queues. This function is the main action dispatcher. It does not return and must be run on the main thread. This routine is normally not used in Arduino environments, as it disables the normal calling of the Arduino <code>loop()</code> function.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_runloop_once","title":"<code>void os_runloop_once ()</code>","text":"<p>Execute run-time jobs from the timer and from the run queues. This function is just like <code>os_runloop()</code>, except that it returns after dispatching the first available job.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-os_gettime","title":"<code>ostime_t os_getTime ()</code>","text":"<p>Query absolute system time (in ticks).</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-us2osticks-s4_t-us","title":"<code>ostime_t us2osticks (s4_t us)</code>","text":"<p>Returns the ticks corresponding to the integer value <code>us</code>. This may be a function-like macro, so <code>us</code> may be evaluated more than once. Any fractional part of the calculation is discarded.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-us2osticksceil-s4_t-us","title":"<code>ostime_t us2osticksCeil (s4_t us)</code>","text":"<p>Returns the ticks corresponding to the integer value <code>us</code>. This may be a function-like macro, so <code>us</code> may be evaluated more than once. If the fractional part of the calculation is non-zero, the result is increased towards positive infinity.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-us2osticksround-s4_t-us","title":"<code>ostime_t us2osticksRound (s4_t us)</code>","text":"<p>Returns the ticks corresponding to the integer value <code>us</code>. This may be a function-like macro, so <code>us</code> may be evaluated more than once. The result is rounded to the nearest tick.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-ms2osticks-s4_t-ms","title":"<code>ostime_t ms2osticks (s4_t ms)</code>","text":"<p>Returns the ticks corresponding to the integer millisecond value ms. This may be a function-like macro, so ms may be evaluated more than once. If the fractional part of the calculation is non-zero, the result is increased towards positive infinity.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-ms2osticksceil-s4_t-ms","title":"<code>ostime_t ms2osticksCeil (s4_t ms)</code>","text":"<p>Returns the ticks corresponding to the integer millisecond value <code>ms</code>. This may be a function-like macro, so <code>ms</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-ms2osticksround-s4_t-ms","title":"<code>ostime_t ms2osticksRound (s4_t ms)</code>","text":"<p>Returns the ticks corresponding to the integer millisecond value <code>ms</code>. This may be a function-like macro, so <code>ms</code> may be evaluated more than once. The result is rounded to the nearest tick.</p>"},{"location":"technical-specification/programming-model-and-api/#ostime_t-sec2osticks-s4_t-sec","title":"<code>ostime_t sec2osticks (s4_t sec)</code>","text":"<p>Returns the ticks corresponding to the integer second value <code>sec</code>. This may be a function-like macro, so <code>sec</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/#s4_t-osticks2ms-ostime_t-os","title":"<code>S4_t osticks2ms (ostime_t os)</code>","text":"<p>Returns the milliseconds corresponding to the tick value <code>os</code>. This may be a function-like macro, so <code>os</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/#s4_t-osticks2us-ostime_t-os","title":"<code>S4_t osticks2us (ostime_t os)</code>","text":"<p>Returns the microseconds corresponding to the tick value <code>os</code>. This may be a function-like macro, so <code>os</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/#application-callbacks","title":"Application callbacks","text":"<p>The LMIC library requires the application to implement a few callback functions. These functions are called by the state engine to query application-specific information and to deliver state events to the application.</p> <p>Upcalls by name from the LMIC to application code are deprecated and will be removed in future versions of the LMIC. The provisioning APIs (<code>os_getDevEui</code>, <code>os_getDevKey</code> and <code>os_getArtEui</code>) will be replaced by secure element APIs in version 4. The onEvent API will be disabled by default in version 4, and removed in version 5.</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_getdeveui-u1_t-buf","title":"<code>void os_getDevEui (u1_t* buf)</code>","text":"<p>The implementation of this callback function has to provide the device EUI and copy it to the given buffer. The device EUI is 8 bytes in length and is stored in little-endian format, that is, least-significant-byte-first (LSBF).</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_getdevkey-u1_t-buf","title":"<code>void os_getDevKey (u1_t* buf)</code>","text":"<p>The implementation of this callback function has to provide the device-specific cryptographic application key and copy it to the given buffer. The device-specific application key is a 128-bit AES key (16 bytes in length).</p>"},{"location":"technical-specification/programming-model-and-api/#void-os_getarteui-u1_t-buf","title":"<code>void os_getArtEui (u1_t* buf)</code>","text":"<p>The implementation of this callback function has to provide the application EUI and copy it to the given buffer. The application EUI is 8 bytes in length and is stored in little-endian format, that is, least-significant-byte-first (LSBF).</p>"},{"location":"technical-specification/programming-model-and-api/#void-onevent-ev_t-ev","title":"<code>void onEvent (ev_t ev)</code>","text":"<p>This function, if provided, is called to report LMIC events (such as transmission complete or downlink message received). It is a legacy function. In V3, if this name conflicts with a name in your application, you can disable the use of this name by putting the following in your configuration file:</p> <pre><code>#define LMIC_ENABLE_onEvent 0\n</code></pre> <p>Upcalls by name from the LMIC to application code are deprecated and will be removed in future versions of the LMIC. A suitable substitute is available. See the discussion of <code>LMIC_registerEventCb()</code>, below.</p>"},{"location":"technical-specification/programming-model-and-api/#the-lmic-struct","title":"The LMIC Struct","text":"<p>Instead of passing numerous parameters back and forth between API and callback functions, information about the protocol state can be accessed via a global <code>LMIC</code> structure as shown below. All fields besides the ones explicitly mentioned below are read-only and should not be modified.</p> <pre><code>struct lmic_t {\nu1_t      frame[MAX_LEN_FRAME];\nu1_t      dataLen;    // 0 no data or zero length data, &gt;0 byte count of data\nu1_t      dataBeg;    // 0 or start of data (dataBeg-1 is port)\nu1_t      txCnt;\nu1_t      txrxFlags;  // transaction flags (TX-RX combo)\nu1_t      pendTxPort;\nu1_t      pendTxConf; // confirmed data\nu1_t      pendTxLen;\nu1_t      pendTxData[MAX_LEN_PAYLOAD];\nu1_t      bcnChnl;\nu1_t      bcnRxsyms;\nostime_t  bcnRxtime;\nbcninfo_t bcninfo;    // Last received beacon info\n\u2026\n\u2026\n};\n</code></pre> <p>This document does not describe the full struct in detail since most of the fields of the LMIC struct are used internally only. The most important fields to examine on reception (event <code>EV_RXCOMPLETE</code> or <code>EV_TXCOMPLETE</code>) are the <code>txrxFlags</code> for status information and <code>frame[]</code> and <code>dataLen</code> / <code>dataBeg</code> for the received application payload data. For data transmission the most important fields are <code>pendTxData[]</code>, <code>pendTxLen</code>, <code>pendTxPort</code> and <code>pendTxConf</code>, which are used as input to the <code>LMIC_setTxData()</code> API function (see 2.5.13).</p> <p>For the <code>EV_RXCOMPLETE</code> and <code>EV_TXCOMPLETE</code> events, the <code>txrxFlags</code> field should be evaluated. The following flags are defined:</p> <ul> <li> <p><code>TXRX_ACK</code>: confirmed UP frame was acked (mutually exclusive with <code>TXRX_NACK</code>)</p> </li> <li> <p><code>TXRX_NACK</code>: confirmed UP frame was not acked (mutually exclusive with <code>TXRX_ACK</code>)</p> </li> <li> <p><code>TXRX_PORT</code>: a port byte is contained in the received frame at offset LMIC.dataBeg \u2013 1.</p> </li> <li> <p><code>TXRX_NOPORT</code>: no port byte is available.</p> </li> <li> <p><code>TXRX_DNW1</code>: received in first DOWN slot (mutually exclusive with <code>TXRX_DNW2</code>)</p> </li> <li> <p><code>TXRX_DNW2</code>: received in second DOWN slot (mutually exclusive with <code>TXRX_DNW1</code>)</p> </li> <li> <p><code>TXRX_PING</code>: received in a scheduled RX slot</p> </li> <li> <p><code>TXRX_LENERR</code>: the transmitted message was abandoned because it was longer than the established data rate.</p> </li> </ul> <p>For the <code>EV_TXCOMPLETE</code> event the fields have the following values:</p> Received frame LMIC.txrxFlags LMIC.dataLen LMIC.dataBeg ACK NACK PORT NOPORT DNW1 DNW2 PING LENERR nothing 0 0 0 1 0 0 0 0 0 0 empty frame x x 0 1 x x 0 0 0 x port only x x 1 0 x x 0 0 0 x port+payload x x 1 0 x x 0 0 x X No message received, transmit message too long 0 0 0 1 x x x 1 0 0 <p>For the <code>EV_RXCOMPLETE</code> event the fields have the following values:</p> Received frame LMIC.txrxFlags LMIC.dataLen LMIC.dataBeg ACK NACK PORT NOPORT DNW1 DNW2 PING empty frame 0 0 0 1 0 0 1 0 x port only 0 0 1 0 0 0 1 0 x port+payload 0 0 1 0 0 0 1 x x"},{"location":"technical-specification/programming-model-and-api/#api-functions","title":"API Functions","text":"<p>The LMIC library offers a set of API functions to control the MAC state and to trigger protocol actions.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_reset","title":"<code>void LMIC_reset ()</code>","text":"<p>Reset the MAC state. Session and pending data transfers will be discarded.</p>"},{"location":"technical-specification/programming-model-and-api/#bit_t-lmic_startjoining","title":"<code>bit_t LMIC_startJoining ()</code>","text":"<p>Immediately start joining the network. Will be called implicitly by other API functions if no session has been established yet. The events <code>EV_JOINING</code> and <code>EV_JOINED</code> or <code>EV_JOIN_FAILED</code> will be generated.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_tryrejoin","title":"<code>void LMIC_tryRejoin ()</code>","text":"<p>Check if other networks are around which can be joined. The session to the current network is kept if no new network is found. The events <code>EV_JOINED</code> or <code>EV_REJOIN_FAILED</code> will be generated.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_setsession-u4_t-netid-devaddr_t-devaddr-u1_t-nwkkey-u1_t-artkey","title":"<code>void LMIC_setSession (u4_t netid, devaddr_t devaddr, u1_t* nwkKey, u1_t* artKey)</code>","text":"<p>Set static session parameters. Instead of dynamically establishing a session by joining the network, precomputed session parameters can be provided. To resume a session with precomputed parameters, the frame sequence counters (<code>LMIC.seqnoUp</code> and <code>LMIC.seqnoDn</code>) must be restored to their latest values.</p>"},{"location":"technical-specification/programming-model-and-api/#bit_t-lmic_setupband-u1_t-bandidx-s1_t-txpow-u2_t-txcap","title":"<code>bit_t LMIC_setupBand (u1_t bandidx, s1_t txpow, u2_t txcap)</code>","text":"<p>Initialize a specific duty-cycle band with the specified transmit power and duty cycle (1/<code>txcap</code>) properties. Returns non-zero for success, zero for failure. Some regions don\u2019t allow you to define duty cycle bands, and in that case this function will always return zero.</p> <p>The argument <code>bandidx</code> selects the band; it must be in the range 0 \u2264 <code>bandidx</code> &lt; <code>MAX_BANDS</code>. For EU-like regions, the following band names are defined: <code>BAND_MILLI</code>, intended to be used for channels with a duty cycle of 0.1%; <code>BAND_CENTI</code>, intended to be used by channels with a duty cycle of 1%; and <code>BAND_DECI</code>, intended to be used by channels with a duty cycle of 10%. A fourth band, <code>BAND_AUX</code>, is available for use by custom code.</p>"},{"location":"technical-specification/programming-model-and-api/#bit_t-lmic_setupchannel-u1_t-channel-u4_t-freq-u2_t-drmap-s1_t-band","title":"<code>bit_t LMIC_setupChannel (u1_t channel, u4_t freq, u2_t drmap, s1_t band)</code>","text":"<p>Create a new channel, or modify an existing channel. If <code>freq</code> is non-zero, the channel is enabled; otherwise it\u2019s disabled. The argument <code>drmap</code> is a bitmap indicating which data rates (0 through 15) are enabled for this channel. Band, if in the range 0..3, assigns the channel to the specified duty-cycle band \u2013 the meaning of this is region-specific. If set to -1, then the appropriate duty-cycle band is selected based on the value of <code>freq</code>.</p> <p>The result is non-zero if the channel was successfully set up; zero otherwise.</p> <p>For any region, there are some channels that cannot be modified (the \u201cdefault channels\u201d). You can\u2019t disable or change these, but it\u2019s not an error to try to set a default channel to its default value.</p> <p>Some regions (such as US915 or AU915) do not allow any channels to be set up.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_disablechannel-u1_t-channel","title":"<code>void LMIC_disableChannel (u1_t channel)</code>","text":"<p>Disable specified channel. Default channels cannot be disabled.</p>"},{"location":"technical-specification/programming-model-and-api/#u1_t-lmic_querynumdefaultchannels","title":"<code>u1_t LMIC_queryNumDefaultChannels ()</code>","text":"<p>Return the number of default channels defined by this region. In the EU868, KR920 and IN866 regions, the result is 3; in the AS923 region, the result is 2; in the US and AU regions, the result is 72.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_setadrmode-bit_t-enabled","title":"<code>void LMIC_setAdrMode (bit_t enabled)</code>","text":"<p>Enable or disable data rate adaptation. Should be turned off if the device is mobile.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_setlinkcheckmode-bit_t-enabled","title":"<code>void LMIC_setLinkCheckMode (bit_t enabled)</code>","text":"<p>Enable/disable link check validation. Link check mode is enabled by default and is used to periodically verify network connectivity. Must be called only if a session is established.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_setdrtxpow-dr_t-dr-s1_t-txpow","title":"<code>void LMIC_setDrTxpow (dr_t dr, s1_t txpow)</code>","text":"<p>Set data rate and transmit power. Should only be used if data rate adaptation is disabled.</p>"},{"location":"technical-specification/programming-model-and-api/#bit_t-lmic_querytxready","title":"<code>bit_t LMIC_queryTxReady ()</code>","text":"<p>Return non-zero if the LMIC is ready to accept transmitted data, zero if an attempt to transmit will be rejected.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_settxdata","title":"<code>void LMIC_setTxData ()</code>","text":"<p>Prepare upstream data transmission at the next possible time. It is assumed, that <code>pendTxData</code>, <code>pendTxLen</code>, <code>pendTxPort</code> and <code>pendTxConf</code> have already been set. Data of length <code>LMIC.pendTxLen</code> from the array <code>LMIC.pendTxData[]</code> will be sent to port <code>LMIC.pendTxPort</code>. If <code>LMIC.pendTxConf</code> is true, confirmation by the server will be requested. The event <code>EV_TXCOMPLETE</code> will be generated when the transaction is complete, i.e. after the data has been sent and eventual down data or a requested acknowledgement has been received.</p> <p>If data rate adaptation is enabled, this function will check whether the message being transmitted is feasible with the current data rate. If not, the data rate will be increased, if possible. This is to provide maximum software compatibility with older applications that do not comprehend the side-effects of rate changes on longer messages. However, it is not guaranteed always to be possible to send a message of a given size, due to regional plan restrictions and current network operating requirements (as provided by downlinks). Prior to V3.2, the LMIC would transmit anyway; as of V3.2, it will report an error. Thus, applications may need to be modified.</p> <p>Because of the numerous post-conditions that must be checked after calling <code>LMIC_setTxData()</code>, we strongly recommend using <code>LMIC_setTxData2()</code> instead.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_settxdata_strict","title":"<code>void LMIC_setTxData_strict ()</code>","text":"<p>Prepare upstream data transmission at the next possible time. The caller must first initialize <code>LMIC.pendTxData[]</code>, <code>LMIC.pendTxLen</code>, <code>LMIC.pendTxPort</code> and <code>LMIC.pendTxConf</code>. Data of length <code>LMIC.pendTxLen</code> from the array <code>LMIC.pendTxData[]</code> will be sent to port <code>LMIC.pendTxPort</code>. If <code>LMIC.pendTxConf</code> is true, confirmation by the network server will be requested. The event <code>EV_TXCOMPLETE</code> will be generated when the transaction is complete, i.e. after the data has been sent and eventual down data or a requested acknowledgement has been received.</p> <p>Unlike <code>LMIC_setTxData()</code>, this API will not try to adjust data rate if the message is too long for the current data rate. See 2.5.13 for a complete discussion.</p> <p>This API is preferred for new applications, for two reasons. First, automatically increasing data rates is arguably not compliant. Second, it isn\u2019t always possible. It\u2019s better for applications to be designed to control operation in the face of slow data rates themselves.</p> <p>Because of the numerous post-conditions that must be checked after calling <code>LMIC_setTxData_strict()</code>, we strongly recommend using <code>LMIC_setTxData2_strict()</code> or <code>LMIC_sendWithCallback_strict()</code> instead.</p>"},{"location":"technical-specification/programming-model-and-api/#lmic_tx_error_t-lmic_settxdata2-u1_t-port-xref2u1_t-data-u1_t-dlen-u1_t-confirmed","title":"<code>lmic_tx_error_t LMIC_setTxData2 (u1_t port, xref2u1_t data, u1_t dlen, u1_t confirmed)</code>","text":"<p>Prepare upstream data transmission at the next possible time. Convenience function for <code>LMIC_setTxData()</code>. If <code>data</code> is <code>NULL</code>, the data in <code>LMIC.pendTxData[]</code> will be used.</p> <p>For compatibility with existing applications, if data rate adaptation is enabled, this function will check whether the message being transmitted is feasible with the current data rate. If not, the data rate will be increased, if possible. See 2.5.13 for a complete discussion.</p> <p>The result type <code>lmic_tx_error_t</code> is a synonym for <code>int</code>. The following values may be returned.</p> Name Value Description LMIC_ERROR_SUCCESS 0 No error occurred, EV_TXCOMPLETE will be posted. LMIC_ERROR_TX_BUSY -1 The LMIC was busy sending another message. This message was not sent. EV_TXCOMPLETE will not be posted for this message. LMIC_ERROR_TX_TOO_LARGE -2 The queued message is too large for the any data rate for this region. This message was not sent. EV_TXCOMPLETE will not be posted for this message. LMIC_ERROR_TX_NOT_FEASIBLE -3 The queued message is not feasible for any enabled data rate. This message was not sent. EV_TXCOMPLETE will not be posted for this message. LMIC_ERROR_TX_FAILED -4 The queued message failed for some other reason than data length, during the initial call to the LMIC to transmit it. This message was not sent. EV_TXCOMPLETE will not be posted for this message."},{"location":"technical-specification/programming-model-and-api/#lmic_tx_error_t-lmic_settxdata2_strict-u1_t-port-xref2u1_t-data-u1_t-dlen-u1_t-confirmed","title":"<code>lmic_tx_error_t LMIC_setTxData2_strict (u1_t port, xref2u1_t data, u1_t dlen, u1_t confirmed)</code>","text":"<p>Prepare upstream data transmission at the next possible time. This function is identical to <code>LMIC_setTxData2()</code>, except that the current data rate will never be changed. Thus, the error return <code>LMIC_ERROR_TX_NOT_FEASIBLE</code> has a slightly different meaning. See 2.5.13 for a complete discussion.</p> Name Value Description LMIC_ERROR_TX_NOT_FEASIBLE -3 The queued message is not feasible for the current data rate. This message was not sent. EV_TXCOMPLETE will not be posted for this message."},{"location":"technical-specification/programming-model-and-api/#lmic_tx_error_t-lmic_sendwithcallback-u1_t-port-u1_t-data-u1_t-dlen-u1_t-confirmed-lmic_txmessage_cb_t-pcb-void-puserdata","title":"<code>lmic_tx_error_t LMIC_sendWithCallback (u1_t port, u1_t *data, u1_t dlen, u1_t confirmed, lmic_txmessage_cb_t *pCb, void *pUserData)</code>","text":"<p>Prepare upstream data transmission at the next possible time, and call a specified function when the transmission completes. Convenience function for <code>LMIC_setTxData()</code>. If <code>data</code> is <code>NULL</code>, the data in <code>LMIC.pendTxData[]</code> will be used. The arguments <code>dlen</code>, <code>confirmed</code>, and <code>port</code> have the same meaning as they do for <code>LMIC_setTxData2()</code>.</p> <p>If the initial call succeeds, the callback will be called, and the event <code>EV_TXCOMPLETE</code> will also be issued. See section 2.5.21 for a complete discussion.</p> <p>For compatibility with existing applications, if data rate adaptation is enabled, this function will check whether the message being transmitted is feasible with the current data rate. If not, the data rate will be increased, if possible. See 2.5.13 for a complete discussion.</p> <p>The callback function has the prototype:</p> <pre><code>typedef void (lmic_txmessage_cb_t)(void *pUserData, int fSuccess);\n</code></pre> <p>It is called by the LMIC when transmission of the message is completed. <code>fSuccess</code> will be non-zero for a transmission that\u2019s judged to be successful, or zero if the transmission is judged to have failed. <code>pUserData</code> is set to the value passed in the corresponding <code>LMIC_sendWithCallback()</code> invocation.</p> <p>See section 2.5.15 for a list of the possible result codes. In all cases, if the result is other than <code>LMIC_ERROR_SUCCESS</code>, the user\u2019s callback function has not been called, and will not be called, and <code>EV_TXCOMPLETE</code> will not be reported.</p>"},{"location":"technical-specification/programming-model-and-api/#lmic_tx_error_t-lmic_sendwithcallback_strict-u1_t-port-u1_t-data-u1_t-dlen-u1_t-confirmed-lmic_txmessage_cb_t-pcb-void-puserdata","title":"<code>lmic_tx_error_t LMIC_sendWithCallback_strict (u1_t port, u1_t *data, u1_t dlen, u1_t confirmed, lmic_txmessage_cb_t *pCb, void *pUserData)</code>","text":"<p>Prepare upstream data transmission at the next possible time, and call a specified function when the transmission completes. This function is identical to <code>LMIC_sendWithCallback()</code>, except that it will not attempt to change the current data rate if the current transmission is not feasible. (See 2.5.13 for a complete discussion.) Thus, the error return <code>LMIC_ERROR_TX_NOT_FEASIBLE</code> has a slightly different meaning, as described in section 2.5.16.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_clrtxdata","title":"<code>void LMIC_clrTxData ()</code>","text":"<p>Remove data previously prepared for upstream transmission. If <code>LMIC_sendWithCallback()</code> or <code>LMIC_sendWithCallback_strict()</code> operations are pending, the callback function will be called with <code>fSuccess</code> set to zero. If transmit messages are pending, the event <code>EV_TXCOMPLETE</code> will be reported.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_registerrxmessagecb-lmic_rxmessage_cb_t-prxmessagecb-void-puserdata","title":"<code>void LMIC_registerRxMessageCb (lmic_rxmessage_cb_t *pRxMessageCb, void *pUserData)</code>","text":"<p>This function registers a callback function to be called when the LMIC detects the reception of a message.</p> <p>The callback function has the prototype:</p> <pre><code>typedef void (lmic_rxmessage_cb_t)(\nvoid *pUserData, u1_t port, const u1_t *pMessage, size_t nMessage\n);\n</code></pre> <p>This function is called from within the LMIC; it should avoid calling LMIC APIs, and avoid time-critical operations.</p> <p>The argument <code>pUserData</code> is set to the value passed to <code>LMIC_registerRxMessageCb()</code>. The argument <code>port</code> is set to the port number of the message. If zero, then a MAC message was received, and <code>nMessage</code> will be zero. The argument <code>pMessage</code> is set to point to the first byte of the message, in the LMIC\u2019s internal buffers, and <code>nMessage</code> is set to the number of bytes of data.</p> <p>The following conditions can be distinguished.</p> port nMessage Meaning 0 \u2260 0 A MAC message was received on port zero. It has already been processed, but it\u2019s delivered to the client for inspection. The LMIC will discard any messages with piggy-backed MAC data targeting port 0. 0 0 An empty payload (no port, no frame) was received. Most likely there is piggybacked MAC data. See below. \u2260 0 0 An empty payload was received for a specific port. It\u2019s up to the application to interpret this. \u2260 0 \u2260 0 A non-empty payload was received for a specific port. It\u2019s up to the application to interpret this. <p>If <code>port</code> is zero and <code>nMessage</code> is zero, piggybacked MAC data can be detected and inspected by checking the value of <code>LMIC.dataBeg</code>. If non-zero, there are <code>LMIC.dataBeg</code> bytes of piggybacked data, and the data can be found at <code>LMIC.frame[0]</code> through <code>LMIC.frame[LMIC.dataBeg-1]</code>.</p> <p>If port is non-zero, piggybacked MAC data can also be checked using the value of <code>LMIC.dataBeg</code>. If greater than 1, there are <code>(LMIC.dataBeg-1)</code> bytes of piggybacked data, and the data can be found at <code>LMIC.frame[0]</code> through <code>LMIC.frame[LMIC.dataBeg-2]</code>.</p> <p>Be aware that if you are also using event callbacks, events will also be reported to the event listening functions. See section 2.5.21 for a complete discussion.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_registereventcb-lmic_event_cb_t-peventcb-void-puserdata","title":"<code>void LMIC_registerEventCb (lmic_event_cb_t *pEventCb, void *pUserData)</code>","text":"<p>This function registers a callback function to be called when the LMIC detects an event.</p> <p>The callback function has the prototype:</p> <pre><code>typedef void (lmic_event_cb_t)(void *pUserData, ev_t ev);\n</code></pre> <p>The argument <code>ev</code> is set to a numeric code indicating the type of event that has occurred. The argument <code>pUserData</code> is set according to the value passed to <code>LMIC_registerEventCb()</code>.</p> <p>The implementation of this callback function may react on certain events and trigger new actions based on the event and the <code>LMIC</code> state. Typically, an implementation processes the events it is interested in and schedules further protocol actions using the LMIC API. The following events will be reported:</p> <ul> <li><code>EV_JOINING</code></li> </ul> <p>The node has started joining the network.</p> <ul> <li><code>EV_JOINED</code></li> </ul> <p>The node has successfully joined the network and is now ready for data exchanges.</p> <ul> <li><code>EV_JOIN_FAILED</code></li> </ul> <p>The node could not join the network (after retrying).</p> <ul> <li><code>EV_REJOIN_FAILED</code></li> </ul> <p>The node did not join a new network but might still be connected to the old network. This feature (trying to join a new network while connected to an old one) is deprecated and will be removed in future versions.</p> <ul> <li><code>EV_TXCOMPLETE</code></li> </ul> <p>The data prepared via <code>LMIC_setTxData()</code> has been sent, and the receive window for downstream data is complete. If confirmation was requested, the acknowledgement has been received. When handling this event, the code can also check for data reception. See 2.5.21.1 for details. If using <code>LMIC_registerRxMessageCb()</code>, it\u2019s best to leave that to the LMIC, which will call the client\u2019s receive-message function as appropriate.</p> <ul> <li><code>EV_RXCOMPLETE</code></li> </ul> <p>A downlink has been received, either in a Class A RX slot, in a Class B ping slot, or (in the future) in a Class C receive window. The code should check the received data. See 2.5.21.1 for details. If using <code>LMIC_sendWithCallback()</code> and <code>LMIC_registerRxMessageCb()</code>, ignore <code>EV_RXCOMPLETE</code> in your event processing function.</p> <ul> <li><code>EV_SCAN_TIMEOUT</code></li> </ul> <p>After a call to <code>LMIC_enableTracking()</code> no beacon was received within the beacon interval. Tracking needs to be restarted.</p> <ul> <li><code>EV_BEACON_FOUND</code></li> </ul> <p>After a call to <code>LMIC_enableTracking()</code> the first beacon has been received within the beacon interval.</p> <ul> <li><code>EV_BEACON_TRACKED</code></li> </ul> <p>The next beacon has been received at the expected time.</p> <ul> <li><code>EV_BEACON_MISSED</code></li> </ul> <p>No beacon was received at the expected time.</p> <ul> <li><code>EV_LOST_TSYNC</code></li> </ul> <p>Beacon was missed repeatedly, and time synchronization has been lost. Tracking or pinging needs to be restarted.</p> <ul> <li><code>EV_RESET</code></li> </ul> <p>Session reset due to rollover of sequence counters. Network will be rejoined automatically to acquire new session.</p> <ul> <li><code>EV_LINK_DEAD</code></li> </ul> <p>No confirmation has been received from the network server for an extended period of time. Transmissions are still possible, but their reception is uncertain.</p> <ul> <li><code>EV_LINK_ALIVE</code></li> </ul> <p>The link was dead, but now is alive again.</p> <ul> <li><code>EV_SCAN_FOUND</code></li> </ul> <p>This event is reserved for future use, and is never reported.</p> <ul> <li><code>EV_TXSTART</code></li> </ul> <p>This event is reported just before telling the radio driver to start transmission.</p> <ul> <li><code>EV_TXCANCELED</code></li> </ul> <p>A pending transmission was canceled, either because of a request to cancel, or as a side effect of an API request, or as a side-effect of a change at the MAC layer (such as frame count overflow).</p> <ul> <li><code>EV_RXSTART</code></li> </ul> <p>The LMIC is about to open a receive window. It\u2019s very important that the event processing routine do as little work as possible \u2013 no more than one millisecond of real time should be consumed, otherwise downlinks may not work properly. Don\u2019t print anything out while processing this event; save data to be printed later. This event is not sent to the <code>onEvent()</code> subroutine, section 2.3.4; it\u2019s only sent to event handlers registered via <code>LMIC_registerEventCb()</code>, section 2.5.21.</p> <ul> <li><code>EV_JOIN_TXCOMPLETE</code></li> </ul> <p>This event indicates the end of a transmission cycle for JOINs. It indicates that both receive windows of the join have been processed without receiving a JoinAccept message from the network.</p> <p>Information about the LMIC state for specific events can be obtained from the global <code>LMIC</code> structure described in section 2.4.</p> <p>Events functions and the transmit/receive call back functions are orthogonal. Multiple routines may be called for a given event.</p> <p>The sequence is as follows.</p> <ol> <li> <p>If using an <code>onEvent()</code> function (the LMIC is configured to use onEvent, and a function named onEvent is provided when using compilers that support weak references), the <code>onEvent()</code> function is called. (For compatibility, the event <code>EV_RXSTART</code> is never sent to the <code>onEvent()</code> function.)</p> </li> <li> <p>If the event indicates that a message was received, and a receive callback is registered, the receive callback is called.</p> </li> <li> <p>If the event indicates that a transmission has completed, and the message was sent with one of the callback APIs, the client callback is invoked.</p> </li> <li> <p>Finally, if the client has registered an event callback, the registered callback is invoked.</p> </li> </ol>"},{"location":"technical-specification/programming-model-and-api/#receiving-downlink-data-with-an-event-function","title":"Receiving Downlink Data with an Event Function","text":"<p>When <code>EV_TXCOMPLETE</code> or <code>EV_RXCOMPLETE</code> is received, the event-processing code should check for downlink data, and pass it to the application. To do this, use code like the following.</p> <pre><code>// Any data to be received?\nif (LMIC.dataLen != 0) {\n// Data was received. Extract port number if any.\nu1_t bPort = 0;\nif (LMIC.txrxFlags &amp; TXRX_PORT)\nbPort = LMIC.frame[LMIC.dataBeg \u2013 1];\n// Call user-supplied function with port #, pMessage, nMessage\nreceiveMessage(\nbPort, LMIC.frame + LMIC.dataBeg, LMIC.dataLen\n);\n}\n</code></pre> <p>If you wish to support alerting the client for zero-length messages, slightly-more complex code must be used.</p> <pre><code>// Any data to be received?\nif (LMIC.dataLen != 0 || LMIC.dataBeg != 0) {\n// Data was received. Extract port number if any.\nu1_t bPort = 0;\nif (LMIC.txrxFlags &amp; TXRX_PORT)\nbPort = LMIC.frame[LMIC.dataBeg \u2013 1];\n// Call user-supplied function with port #, pMessage, nMessage;\n// nMessage might be zero.\nreceiveMessage(\nbPort, LMIC.frame + LMIC.dataBeg, LMIC.dataLen\n);\n}\n</code></pre>"},{"location":"technical-specification/programming-model-and-api/#bit_t-lmic_enabletracking-u1_t-trybcninfo","title":"<code>bit_t LMIC_enableTracking (u1_t tryBcnInfo)</code>","text":"<p>Enable beacon tracking. A value of 0 for <code>tryBcnInfo</code> indicates to start scanning for the beacon immediately. A non-zero value specifies the number of attempts to query the server for the exact beacon arrival time. The query requests will be sent within the next upstream frames (no frame will be generated). If no answer is received scanning will be started. The events <code>EV_BEACON_FOUND</code> or <code>EV_SCAN_TIMEOUT</code> will be generated for the first beacon, and the events <code>EV_BEACON_TRACKED</code>, <code>EV_BEACON_MISSED</code> or <code>EV_LOST_TSYNC</code> will be generated for subsequent beacons.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_disabletracking","title":"<code>void LMIC_disableTracking ()</code>","text":"<p>Disable beacon tracking. The beacon will be no longer tracked and, therefore, also pinging will be disabled.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_setpingable-u1_t-intvexp","title":"<code>void LMIC_setPingable (u1_t intvExp)</code>","text":"<p>Enable pinging and set the downstream listen interval. Pinging will be enabled with the next upstream frame (no frame will be generated). The listen interval is 2^<code>intvExp</code> seconds, valid values for <code>intvExp</code> are 0-7. This API function requires a valid session established with the network server either via <code>LMIC_startJoining()</code> or <code>LMIC_setSession()</code> functions (see sections 2.5.2 and 2.5.4). If beacon tracking is not yet enabled, scanning will be started immediately. In order to avoid scanning, the beacon can be located more efficiently by a preceding call to <code>LMIC_enableTracking()</code> with a non-zero parameter. Additionally to the events mentioned for <code>LMIC_enableTracking()</code>, the event <code>EV_RXCOMPLETE</code> will be generated whenever downstream data has been received in a ping slot.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_stoppingable","title":"<code>void LMIC_stopPingable ()</code>","text":"<p>Stop listening for downstream data. Periodical reception is disabled, but beacons will still be tracked. In order to stop tracking, the beacon a call to <code>LMIC_disableTracking()</code> is required.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_sendalive","title":"<code>void LMIC_sendAlive ()</code>","text":"<p>Send one empty upstream MAC frame as soon as possible. Might be used to signal liveness or to transport pending MAC options, and to open a receive window.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_shutdown","title":"<code>void LMIC_shutdown ()</code>","text":"<p>Stop all MAC activity. Subsequently, the MAC needs to be reset via a call to <code>LMIC_reset()</code> and new protocol actions need to be initiated.</p>"},{"location":"technical-specification/programming-model-and-api/#void-lmic_requestnetworktime-lmic_request_network_time_cb_t-void-puserdata","title":"<code>void LMIC_requestNetworkTime (lmic_request_network_time_cb_t *, void *pUserData)</code>","text":"<p>Register a network time MAC request to be forwarded with the next uplink frame. The first argument is a pointer to a function, with the following signature.</p> <pre><code>typedef void LMIC_ABI_STD lmic_request_network_time_cb_t (void * pUserData, int flagSuccess);\n</code></pre> <p>This function is called after processing is complete. <code>flagSuccess</code> will be non-zero if time was successfully obtained, zero otherwise. <code>in the callback will be set according to the value of</code> in the original call to <code>LMIC_requestNetworkTime()</code>. If not used, please use a NULL pointer.</p>"},{"location":"technical-specification/programming-model-and-api/#int-lmic_getnetworktimereference-lmic_time_reference_t-preference","title":"<code>int LMIC_getNetworkTimeReference (lmic_time_reference_t *pReference)</code>","text":"<p>Fetch a time reference for the most-recently obtained network time. The <code>lmic_time_reference_t</code> structure at <code>pReference</code> is updated with the relevant information. The result of this call is a Boolean indicating whether a valid time was returned if non-zero, a valid time was returned, otherwise no valid time was available (or <code>pReference</code> was NULL). If unsuccessful, <code>*pReference</code> is not modified.</p> <p>The structure <code>lmic_time_reference_t</code> has the following fields.</p> <pre><code>typedef struct {\nostime_t tLocal;\nlmic_gpstime_t tNetwork;\n} lmic_time_reference_t;\n</code></pre> <p><code>tNetwork</code> is set to the GPS time transmitted by the network in the <code>DeviceTimeAns</code> message. <code>tLocal</code> is calculated, by converting the fractional part of the <code>DeviceTimeAns</code> message into OS ticks, and subtracting that from the completion time of the <code>DeviceTimeReq</code> message.</p> <p>The two fields establish a relationship between a given OS time <code>tLocal</code> and a given GPS time <code>tNetwork</code>. From this, you can work out the current OS time corresponding to a given GPS time, using a formula like <code>ostime = ref.tLocal + sec2osticks(gpstime \u2013 ref.tNetwork)</code>.</p>"},{"location":"technical-specification/programming-model-and-api/#uint8_t-lmic_setbatterylevel-uint8_t-ubattlevel","title":"<code>uint8_t LMIC_setBatteryLevel (uint8_t uBattLevel)</code>","text":"<p>Set the battery level that will be returned to the network server by the MAC in <code>DevStatusAns</code> messages. The result of this call is the previous value. The internal value is initialized by <code>LMIC_init()</code> to <code>MCMD_DEVS_NOINFO</code>. The internal value is not changed by <code>LMIC_reset()</code>.</p> <p>The possible values of <code>uBattLevel</code> are:</p> Value Name Meaning 0 MCMD_DEVS_EXT_POWER Device is operating on external power. 0x01 MCMD_DEVS_BATT_MIN Device is operating on battery power; battery is at minimum value. \u2026 0xFE MCMD_DEVS_BATT_MAX Device is operating on battery power; battery is at maximum value 0xFF MCMD_DEVS_BATT_NOINFO The device doesn\u2019t know its battery / power state, and was unable to measure the battery level. <p>If the application knows the battery level as a % of capacity (from 0% to 100%, inclusive), it should calculate as follows.</p> <pre><code>uBattLevel = (MCMD_DEVS_BAT_MAX \u2013 MCMD_DEVS_BAT_MIN253 + 50) * uBatteryPercent / 100;\nuBattLevel += MCMD_DEVS_BAT_MIN;\nLMIC_setBatteryLevel(uBattLevel);\n</code></pre>"},{"location":"technical-specification/programming-model-and-api/#uint8_t-lmic_getbatterylevel-void","title":"<code>uint8_t LMIC_getBatteryLevel (void)</code>","text":"<p>This function returns the battery level currently stored for use by the MAC. The value is as described in <code>LMIC_setBatteryLevel()</code>.</p>"},{"location":"technical-specification/release-history/","title":"Release History","text":"<p>The Arduino LMIC release history is in the README.md file at https://github.com/mcci-catena/arduino-lmic.</p>"},{"location":"technical-specification/release-history/#ibm-release-history","title":"IBM Release History","text":""},{"location":"technical-specification/release-history/#16-jul-2016","title":"1.6 - Jul 2016","text":"<p>Changed license to BSD. Included modem application (see examples/modem and LMIC-Modem.pdf). Added STM32 hardware drivers and Blipper board-specific peripheral code.</p>"},{"location":"technical-specification/release-history/#15-may-2015","title":"1.5 - May 2015","text":"<p>Bug fixes and documentation update.</p>"},{"location":"technical-specification/release-history/#14-march-2015","title":"1.4 - March 2015","text":"<p>Changed API: port indicator flag in <code>LMIC.txrxFlags</code> has been inverted (now <code>TXRX_PORT</code>, previously <code>TXRX_NOPORT</code>). Internal bug fixes. Document formatting.</p>"},{"location":"technical-specification/release-history/#12-february-2015","title":"1.2 - February 2015","text":"<p>Added APIs <code>LMIC_setupBand()</code>, <code>LMIC_setupChannel()</code>, <code>LMIC_disableChannel()</code>, <code>LMIC_setLinkCheckMode()</code>. Minor internal fixes.</p>"},{"location":"technical-specification/release-history/#11-january-2015","title":"1.1 - January 2015","text":"<p>Added API <code>LMIC_setSession()</code>. Minor internal fixes.</p>"},{"location":"technical-specification/release-history/#10-november-2014","title":"1.0 - November 2014","text":"<p>Initial version.</p>"},{"location":"technical-specification/programming-model-and-api/","title":"Introduction","text":"<p>The LMIC library can be accessed via a set of API functions, run-time functions, callback functions, and a global LMIC data structure. The interface is defined in a single header file \u201c<code>lmic.h</code>\u201d which all applications should include.</p> <pre><code>#include \"lmic.h\"\n</code></pre> <p>The library version follows Semantic Versioning 2.0.0 (https://semver.org/). A single symbol represents the version. Bits 31..24 represent the major version, bits 23..15 the minor version, and bits 15..8 represent the patch. Bits 7..0 are used for representing the pre-release, called \u201cLOCAL\u201d for historical reasons.</p> <p>A function-like macro, <code>ARDUINO_LMIC_VERSION_CALC()</code>, is used to construct version numbers.</p> <pre><code>#define ARDUINO_LMIC_VERSION ARDUINO_LMIC_VERSION_CALC(2, 3, 2, 0)\n</code></pre> <p>For convenience, the library supplies function-like macros <code>ARDUINO_LMIC_VERSION_GET_MAJOR()</code>, <code>ARDUINO_LMIC_VERSION_GET_MINOR()</code>, <code>ARDUINO_LMIC_VERSION_GET_PATCH()</code>, and <code>ARDUINO_LMIC_\u00adVERSION_\u00adGET_LOCAL()</code>, which extract the appropriate field from a version number.</p> <p>Version numbers are represented naively \u2013 the four fields are simply packed together into a 32-bit word. This makes them easy to display, but hard to compare. Pre-releases are numbered higher than releases, but compare less. Several macros are provided to make it easy to compare versions numbers. <code>ARDUINO_LMIC_VERSION_TO_ORDINAL()</code> converts a version number computed by <code>ARDUINO_LMIC_VERSION_CALC()</code> into an integer that can be compared using the normal C comparison operators. <code>ARDUINO_LMIC_VERSION_COMPARE_LT(v1, v2)</code> compares two version numbers and returns non-zero if v1 is less than v2 (after converting both to ordinals). <code>ARDUINO_LMIC_VERSION_COMPARE_LE(v1, v2)</code>, <code>ARDUINO_LMIC_VERSION_COMPARE_GT(v1, v2)</code>, and <code>ARDUINO_LMIC_VERSION_COMPARE_GE(v1, v2)</code> test for less-than-or-equal, greater-than, or greater-than-or-equal relationships.</p> <p>To identify the original version of the IBM LMIC library two constants are defined in this header file.</p> <pre><code>#define LMIC_VERSION_MAJOR 1\n#define LMIC_VERSION_MINOR 6\n</code></pre> <p>These version strings identify the base version of the library, and will not change.</p>"},{"location":"technical-specification/programming-model-and-api/#programming-model","title":"Programming Model","text":"<p>The LMIC library offers a simple event-based programming model where all protocol events are dispatched to the application\u2019s <code>onEvent()</code> callback function (see 2.3.4). In order to free the application of details like timings or interrupts, the library has a built-in run-time environment to take care of timer queues and job management.</p>"},{"location":"technical-specification/programming-model-and-api/#application-jobs","title":"Application jobs","text":"<p>In this model all application code is run in so-called jobs which are executed on the main thread by the run-time scheduler function <code>os_runloop()</code> (see 2.2.6). These application jobs are coded as normal C functions and can be managed using the run-time functions described in section 2.1.3. For the job management an additional per job control struct <code>osjob_t</code> is required which identifies the job and stores context information. Jobs must not be long-running in order to ensure seamless operation! They should only update state and schedule actions, which will trigger new job or event callbacks.</p>"},{"location":"technical-specification/programming-model-and-api/#main-event-loop","title":"Main event loop","text":"<p>All an application must do is to initialize the run-time environment using the <code>os_init()</code> or <code>os_init_ex()</code> function and then periodically call the job scheduler function <code>os_runloop_once()</code>. In order to bootstrap protocol actions and generate events, an initial job needs to be set up. Therefore, a startup job is scheduled using the <code>os_setCallback()</code> function.</p> <pre><code>osjob_t initjob;\nvoid setup () {\n// initialize run-time env\nos_init();\n// setup initial job\nos_setCallback(&amp;initjob, initfunc);\n}\nvoid loop () {\n// execute scheduled jobs and events\nos_runloop_once();\n}\n</code></pre> <p>The startup code shown in the <code>initfunc()</code> function below initializes the MAC and starts joining the network.</p> <pre><code>// initial job\nstatic void initfunc (osjob_t* j) {\n// reset MAC state\nLMIC_reset();\n// start joining\nLMIC_startJoining();\n// init done - onEvent() callback will be invoked...\n}\n</code></pre> <p>The <code>initfunc()</code> function will return immediately, and the <code>onEvent()</code> callback function will be invoked by the scheduler later on for the events <code>EV_JOINING</code>, <code>EV_JOINED</code> or <code>EV_JOIN_FAILED</code>.</p>"},{"location":"technical-specification/programming-model-and-api/#os-time","title":"OS time","text":"<p>The LMIC uses values of the type <code>ostime_t</code> to represent time in ticks. The rate of these ticks defaults to 32768 ticks per second, but may be configured at compile time to any value between 10000 ticks per second and 64516 ticks per second.</p> <p>In general, one tick is not an integral number of microseconds or milliseconds. Convenience functions are provided for switching back and forth.</p> <pre><code>typedef int32_t ostime_t;\n</code></pre> <p>Note that this is a signed integer value; care must be taken when computing differences to avoid being fooled by overflow. OS time starts at zero, and increments uniformly to <code>INT32_MAX</code>; it then wraps to <code>INT32_MIN</code> and increments uniformly up to zero, and repeats. Rather than comparing two <code>ostime_t</code> values, recommended practice is to subtract them and see if the result is positive or negative.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/","title":"API Functions","text":"<p>The LMIC library offers a set of API functions to control the MAC state and to trigger protocol actions.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_reset","title":"<code>void LMIC_reset ()</code>","text":"<p>Reset the MAC state. Session and pending data transfers will be discarded.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#bit_t-lmic_startjoining","title":"<code>bit_t LMIC_startJoining ()</code>","text":"<p>Immediately start joining the network. Will be called implicitly by other API functions if no session has been established yet. The events <code>EV_JOINING</code> and <code>EV_JOINED</code> or <code>EV_JOIN_FAILED</code> will be generated.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_tryrejoin","title":"<code>void LMIC_tryRejoin ()</code>","text":"<p>Check if other networks are around which can be joined. The session to the current network is kept if no new network is found. The events <code>EV_JOINED</code> or <code>EV_REJOIN_FAILED</code> will be generated.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_setsession-u4_t-netid-devaddr_t-devaddr-u1_t-nwkkey-u1_t-artkey","title":"<code>void LMIC_setSession (u4_t netid, devaddr_t devaddr, u1_t* nwkKey, u1_t* artKey)</code>","text":"<p>Set static session parameters. Instead of dynamically establishing a session by joining the network, precomputed session parameters can be provided. To resume a session with precomputed parameters, the frame sequence counters (<code>LMIC.seqnoUp</code> and <code>LMIC.seqnoDn</code>) must be restored to their latest values.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#bit_t-lmic_setupband-u1_t-bandidx-s1_t-txpow-u2_t-txcap","title":"<code>bit_t LMIC_setupBand (u1_t bandidx, s1_t txpow, u2_t txcap)</code>","text":"<p>Initialize a specific duty-cycle band with the specified transmit power and duty cycle (1/<code>txcap</code>) properties. Returns non-zero for success, zero for failure. Some regions don\u2019t allow you to define duty cycle bands, and in that case this function will always return zero.</p> <p>The argument <code>bandidx</code> selects the band; it must be in the range 0 \u2264 <code>bandidx</code> &lt; <code>MAX_BANDS</code>. For EU-like regions, the following band names are defined: <code>BAND_MILLI</code>, intended to be used for channels with a duty cycle of 0.1%; <code>BAND_CENTI</code>, intended to be used by channels with a duty cycle of 1%; and <code>BAND_DECI</code>, intended to be used by channels with a duty cycle of 10%. A fourth band, <code>BAND_AUX</code>, is available for use by custom code.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#bit_t-lmic_setupchannel-u1_t-channel-u4_t-freq-u2_t-drmap-s1_t-band","title":"<code>bit_t LMIC_setupChannel (u1_t channel, u4_t freq, u2_t drmap, s1_t band)</code>","text":"<p>Create a new channel, or modify an existing channel. If <code>freq</code> is non-zero, the channel is enabled; otherwise it\u2019s disabled. The argument <code>drmap</code> is a bitmap indicating which data rates (0 through 15) are enabled for this channel. Band, if in the range 0..3, assigns the channel to the specified duty-cycle band \u2013 the meaning of this is region-specific. If set to -1, then the appropriate duty-cycle band is selected based on the value of <code>freq</code>.</p> <p>The result is non-zero if the channel was successfully set up; zero otherwise.</p> <p>For any region, there are some channels that cannot be modified (the \u201cdefault channels\u201d). You can\u2019t disable or change these, but it\u2019s not an error to try to set a default channel to its default value.</p> <p>Some regions (such as US915 or AU915) do not allow any channels to be set up.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_disablechannel-u1_t-channel","title":"<code>void LMIC_disableChannel (u1_t channel)</code>","text":"<p>Disable specified channel. Default channels cannot be disabled.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#u1_t-lmic_querynumdefaultchannels","title":"<code>u1_t LMIC_queryNumDefaultChannels ()</code>","text":"<p>Return the number of default channels defined by this region. In the EU868, KR920 and IN866 regions, the result is 3; in the AS923 region, the result is 2; in the US and AU regions, the result is 72.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_setadrmode-bit_t-enabled","title":"<code>void LMIC_setAdrMode (bit_t enabled)</code>","text":"<p>Enable or disable data rate adaptation. Should be turned off if the device is mobile.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_setlinkcheckmode-bit_t-enabled","title":"<code>void LMIC_setLinkCheckMode (bit_t enabled)</code>","text":"<p>Enable/disable link check validation. Link check mode is enabled by default and is used to periodically verify network connectivity. Must be called only if a session is established.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_setdrtxpow-dr_t-dr-s1_t-txpow","title":"<code>void LMIC_setDrTxpow (dr_t dr, s1_t txpow)</code>","text":"<p>Set data rate and transmit power. Should only be used if data rate adaptation is disabled.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#bit_t-lmic_querytxready","title":"<code>bit_t LMIC_queryTxReady ()</code>","text":"<p>Return non-zero if the LMIC is ready to accept transmitted data, zero if an attempt to transmit will be rejected.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_settxdata","title":"<code>void LMIC_setTxData ()</code>","text":"<p>Prepare upstream data transmission at the next possible time. It is assumed, that <code>pendTxData</code>, <code>pendTxLen</code>, <code>pendTxPort</code> and <code>pendTxConf</code> have already been set. Data of length <code>LMIC.pendTxLen</code> from the array <code>LMIC.pendTxData[]</code> will be sent to port <code>LMIC.pendTxPort</code>. If <code>LMIC.pendTxConf</code> is true, confirmation by the server will be requested. The event <code>EV_TXCOMPLETE</code> will be generated when the transaction is complete, i.e. after the data has been sent and eventual down data or a requested acknowledgement has been received.</p> <p>If data rate adaptation is enabled, this function will check whether the message being transmitted is feasible with the current data rate. If not, the data rate will be increased, if possible. This is to provide maximum software compatibility with older applications that do not comprehend the side-effects of rate changes on longer messages. However, it is not guaranteed always to be possible to send a message of a given size, due to regional plan restrictions and current network operating requirements (as provided by downlinks). Prior to V3.2, the LMIC would transmit anyway; as of V3.2, it will report an error. Thus, applications may need to be modified.</p> <p>Because of the numerous post-conditions that must be checked after calling <code>LMIC_setTxData()</code>, we strongly recommend using <code>LMIC_setTxData2()</code> instead.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_settxdata_strict","title":"<code>void LMIC_setTxData_strict ()</code>","text":"<p>Prepare upstream data transmission at the next possible time. The caller must first initialize <code>LMIC.pendTxData[]</code>, <code>LMIC.pendTxLen</code>, <code>LMIC.pendTxPort</code> and <code>LMIC.pendTxConf</code>. Data of length <code>LMIC.pendTxLen</code> from the array <code>LMIC.pendTxData[]</code> will be sent to port <code>LMIC.pendTxPort</code>. If <code>LMIC.pendTxConf</code> is true, confirmation by the network server will be requested. The event <code>EV_TXCOMPLETE</code> will be generated when the transaction is complete, i.e. after the data has been sent and eventual down data or a requested acknowledgement has been received.</p> <p>Unlike <code>LMIC_setTxData()</code>, this API will not try to adjust data rate if the message is too long for the current data rate. See 2.5.13 for a complete discussion.</p> <p>This API is preferred for new applications, for two reasons. First, automatically increasing data rates is arguably not compliant. Second, it isn\u2019t always possible. It\u2019s better for applications to be designed to control operation in the face of slow data rates themselves.</p> <p>Because of the numerous post-conditions that must be checked after calling <code>LMIC_setTxData_strict()</code>, we strongly recommend using <code>LMIC_setTxData2_strict()</code> or <code>LMIC_sendWithCallback_strict()</code> instead.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#lmic_tx_error_t-lmic_settxdata2-u1_t-port-xref2u1_t-data-u1_t-dlen-u1_t-confirmed","title":"<code>lmic_tx_error_t LMIC_setTxData2 (u1_t port, xref2u1_t data, u1_t dlen, u1_t confirmed)</code>","text":"<p>Prepare upstream data transmission at the next possible time. Convenience function for <code>LMIC_setTxData()</code>. If <code>data</code> is <code>NULL</code>, the data in <code>LMIC.pendTxData[]</code> will be used.</p> <p>For compatibility with existing applications, if data rate adaptation is enabled, this function will check whether the message being transmitted is feasible with the current data rate. If not, the data rate will be increased, if possible. See 2.5.13 for a complete discussion.</p> <p>The result type <code>lmic_tx_error_t</code> is a synonym for <code>int</code>. The following values may be returned.</p> Name Value Description LMIC_ERROR_SUCCESS 0 No error occurred, EV_TXCOMPLETE will be posted. LMIC_ERROR_TX_BUSY -1 The LMIC was busy sending another message. This message was not sent. EV_TXCOMPLETE will not be posted for this message. LMIC_ERROR_TX_TOO_LARGE -2 The queued message is too large for the any data rate for this region. This message was not sent. EV_TXCOMPLETE will not be posted for this message. LMIC_ERROR_TX_NOT_FEASIBLE -3 The queued message is not feasible for any enabled data rate. This message was not sent. EV_TXCOMPLETE will not be posted for this message. LMIC_ERROR_TX_FAILED -4 The queued message failed for some other reason than data length, during the initial call to the LMIC to transmit it. This message was not sent. EV_TXCOMPLETE will not be posted for this message."},{"location":"technical-specification/programming-model-and-api/api-functions/#lmic_tx_error_t-lmic_settxdata2_strict-u1_t-port-xref2u1_t-data-u1_t-dlen-u1_t-confirmed","title":"<code>lmic_tx_error_t LMIC_setTxData2_strict (u1_t port, xref2u1_t data, u1_t dlen, u1_t confirmed)</code>","text":"<p>Prepare upstream data transmission at the next possible time. This function is identical to <code>LMIC_setTxData2()</code>, except that the current data rate will never be changed. Thus, the error return <code>LMIC_ERROR_TX_NOT_FEASIBLE</code> has a slightly different meaning. See 2.5.13 for a complete discussion.</p> Name Value Description LMIC_ERROR_TX_NOT_FEASIBLE -3 The queued message is not feasible for the current data rate. This message was not sent. EV_TXCOMPLETE will not be posted for this message."},{"location":"technical-specification/programming-model-and-api/api-functions/#lmic_tx_error_t-lmic_sendwithcallback-u1_t-port-u1_t-data-u1_t-dlen-u1_t-confirmed-lmic_txmessage_cb_t-pcb-void-puserdata","title":"<code>lmic_tx_error_t LMIC_sendWithCallback (u1_t port, u1_t *data, u1_t dlen, u1_t confirmed, lmic_txmessage_cb_t *pCb, void *pUserData)</code>","text":"<p>Prepare upstream data transmission at the next possible time, and call a specified function when the transmission completes. Convenience function for <code>LMIC_setTxData()</code>. If <code>data</code> is <code>NULL</code>, the data in <code>LMIC.pendTxData[]</code> will be used. The arguments <code>dlen</code>, <code>confirmed</code>, and <code>port</code> have the same meaning as they do for <code>LMIC_setTxData2()</code>.</p> <p>If the initial call succeeds, the callback will be called, and the event <code>EV_TXCOMPLETE</code> will also be issued. See section 2.5.21 for a complete discussion.</p> <p>For compatibility with existing applications, if data rate adaptation is enabled, this function will check whether the message being transmitted is feasible with the current data rate. If not, the data rate will be increased, if possible. See 2.5.13 for a complete discussion.</p> <p>The callback function has the prototype:</p> <pre><code>typedef void (lmic_txmessage_cb_t)(void *pUserData, int fSuccess);\n</code></pre> <p>It is called by the LMIC when transmission of the message is completed. <code>fSuccess</code> will be non-zero for a transmission that\u2019s judged to be successful, or zero if the transmission is judged to have failed. <code>pUserData</code> is set to the value passed in the corresponding <code>LMIC_sendWithCallback()</code> invocation.</p> <p>See section 2.5.15 for a list of the possible result codes. In all cases, if the result is other than <code>LMIC_ERROR_SUCCESS</code>, the user\u2019s callback function has not been called, and will not be called, and <code>EV_TXCOMPLETE</code> will not be reported.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#lmic_tx_error_t-lmic_sendwithcallback_strict-u1_t-port-u1_t-data-u1_t-dlen-u1_t-confirmed-lmic_txmessage_cb_t-pcb-void-puserdata","title":"<code>lmic_tx_error_t LMIC_sendWithCallback_strict (u1_t port, u1_t *data, u1_t dlen, u1_t confirmed, lmic_txmessage_cb_t *pCb, void *pUserData)</code>","text":"<p>Prepare upstream data transmission at the next possible time, and call a specified function when the transmission completes. This function is identical to <code>LMIC_sendWithCallback()</code>, except that it will not attempt to change the current data rate if the current transmission is not feasible. (See 2.5.13 for a complete discussion.) Thus, the error return <code>LMIC_ERROR_TX_NOT_FEASIBLE</code> has a slightly different meaning, as described in section 2.5.16.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_clrtxdata","title":"<code>void LMIC_clrTxData ()</code>","text":"<p>Remove data previously prepared for upstream transmission. If <code>LMIC_sendWithCallback()</code> or <code>LMIC_sendWithCallback_strict()</code> operations are pending, the callback function will be called with <code>fSuccess</code> set to zero. If transmit messages are pending, the event <code>EV_TXCOMPLETE</code> will be reported.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_registerrxmessagecb-lmic_rxmessage_cb_t-prxmessagecb-void-puserdata","title":"<code>void LMIC_registerRxMessageCb (lmic_rxmessage_cb_t *pRxMessageCb, void *pUserData)</code>","text":"<p>This function registers a callback function to be called when the LMIC detects the reception of a message.</p> <p>The callback function has the prototype:</p> <pre><code>typedef void (lmic_rxmessage_cb_t)(\nvoid *pUserData, u1_t port, const u1_t *pMessage, size_t nMessage\n);\n</code></pre> <p>This function is called from within the LMIC; it should avoid calling LMIC APIs, and avoid time-critical operations.</p> <p>The argument <code>pUserData</code> is set to the value passed to <code>LMIC_registerRxMessageCb()</code>. The argument <code>port</code> is set to the port number of the message. If zero, then a MAC message was received, and <code>nMessage</code> will be zero. The argument <code>pMessage</code> is set to point to the first byte of the message, in the LMIC\u2019s internal buffers, and <code>nMessage</code> is set to the number of bytes of data.</p> <p>The following conditions can be distinguished.</p> port nMessage Meaning 0 \u2260 0 A MAC message was received on port zero. It has already been processed, but it\u2019s delivered to the client for inspection. The LMIC will discard any messages with piggy-backed MAC data targeting port 0. 0 0 An empty payload (no port, no frame) was received. Most likely there is piggybacked MAC data. See below. \u2260 0 0 An empty payload was received for a specific port. It\u2019s up to the application to interpret this. \u2260 0 \u2260 0 A non-empty payload was received for a specific port. It\u2019s up to the application to interpret this. <p>If <code>port</code> is zero and <code>nMessage</code> is zero, piggybacked MAC data can be detected and inspected by checking the value of <code>LMIC.dataBeg</code>. If non-zero, there are <code>LMIC.dataBeg</code> bytes of piggybacked data, and the data can be found at <code>LMIC.frame[0]</code> through <code>LMIC.frame[LMIC.dataBeg-1]</code>.</p> <p>If port is non-zero, piggybacked MAC data can also be checked using the value of <code>LMIC.dataBeg</code>. If greater than 1, there are <code>(LMIC.dataBeg-1)</code> bytes of piggybacked data, and the data can be found at <code>LMIC.frame[0]</code> through <code>LMIC.frame[LMIC.dataBeg-2]</code>.</p> <p>Be aware that if you are also using event callbacks, events will also be reported to the event listening functions. See section 2.5.21 for a complete discussion.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_registereventcb-lmic_event_cb_t-peventcb-void-puserdata","title":"<code>void LMIC_registerEventCb (lmic_event_cb_t *pEventCb, void *pUserData)</code>","text":"<p>This function registers a callback function to be called when the LMIC detects an event.</p> <p>The callback function has the prototype:</p> <pre><code>typedef void (lmic_event_cb_t)(void *pUserData, ev_t ev);\n</code></pre> <p>The argument <code>ev</code> is set to a numeric code indicating the type of event that has occurred. The argument <code>pUserData</code> is set according to the value passed to <code>LMIC_registerEventCb()</code>.</p> <p>The implementation of this callback function may react on certain events and trigger new actions based on the event and the <code>LMIC</code> state. Typically, an implementation processes the events it is interested in and schedules further protocol actions using the LMIC API. The following events will be reported:</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_joining","title":"<code>EV_JOINING</code>","text":"<p>The node has started joining the network.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_joined","title":"<code>EV_JOINED</code>","text":"<p>The node has successfully joined the network and is now ready for data exchanges.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_join_failed","title":"<code>EV_JOIN_FAILED</code>","text":"<p>The node could not join the network (after retrying).</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_rejoin_failed","title":"<code>EV_REJOIN_FAILED</code>","text":"<p>The node did not join a new network but might still be connected to the old network. This feature (trying to join a new network while connected to an old one) is deprecated and will be removed in future versions.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_txcomplete","title":"<code>EV_TXCOMPLETE</code>","text":"<p>The data prepared via <code>LMIC_setTxData()</code> has been sent, and the receive window for downstream data is complete. If confirmation was requested, the acknowledgement has been received. When handling this event, the code can also check for data reception. See 2.5.21.1 for details. If using <code>LMIC_registerRxMessageCb()</code>, it\u2019s best to leave that to the LMIC, which will call the client\u2019s receive-message function as appropriate.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_rxcomplete","title":"<code>EV_RXCOMPLETE</code>","text":"<p>A downlink has been received, either in a Class A RX slot, in a Class B ping slot, or (in the future) in a Class C receive window. The code should check the received data. See 2.5.21.1 for details. If using <code>LMIC_sendWithCallback()</code> and <code>LMIC_registerRxMessageCb()</code>, ignore <code>EV_RXCOMPLETE</code> in your event processing function.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_scan_timeout","title":"<code>EV_SCAN_TIMEOUT</code>","text":"<p>After a call to <code>LMIC_enableTracking()</code> no beacon was received within the beacon interval. Tracking needs to be restarted.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_beacon_found","title":"<code>EV_BEACON_FOUND</code>","text":"<p>After a call to <code>LMIC_enableTracking()</code> the first beacon has been received within the beacon interval.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_beacon_tracked","title":"<code>EV_BEACON_TRACKED</code>","text":"<p>The next beacon has been received at the expected time.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_beacon_missed","title":"<code>EV_BEACON_MISSED</code>","text":"<p>No beacon was received at the expected time.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_lost_tsync","title":"<code>EV_LOST_TSYNC</code>","text":"<p>Beacon was missed repeatedly, and time synchronization has been lost. Tracking or pinging needs to be restarted.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_reset","title":"<code>EV_RESET</code>","text":"<p>Session reset due to rollover of sequence counters. Network will be rejoined automatically to acquire new session.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_link_dead","title":"<code>EV_LINK_DEAD</code>","text":"<p>No confirmation has been received from the network server for an extended period of time. Transmissions are still possible, but their reception is uncertain.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_link_alive","title":"<code>EV_LINK_ALIVE</code>","text":"<p>The link was dead, but now is alive again.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_scan_found","title":"<code>EV_SCAN_FOUND</code>","text":"<p>This event is reserved for future use, and is never reported.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_txstart","title":"<code>EV_TXSTART</code>","text":"<p>This event is reported just before telling the radio driver to start transmission.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_txcanceled","title":"<code>EV_TXCANCELED</code>","text":"<p>A pending transmission was canceled, either because of a request to cancel, or as a side effect of an API request, or as a side-effect of a change at the MAC layer (such as frame count overflow).</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_rxstart","title":"<code>EV_RXSTART</code>","text":"<p>The LMIC is about to open a receive window. It\u2019s very important that the event processing routine do as little work as possible \u2013 no more than one millisecond of real time should be consumed, otherwise downlinks may not work properly. Don\u2019t print anything out while processing this event; save data to be printed later. This event is not sent to the <code>onEvent()</code> subroutine, section 2.3.4; it\u2019s only sent to event handlers registered via <code>LMIC_registerEventCb()</code>, section 2.5.21.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#ev_join_txcomplete","title":"<code>EV_JOIN_TXCOMPLETE</code>","text":"<p>This event indicates the end of a transmission cycle for JOINs. It indicates that both receive windows of the join have been processed without receiving a JoinAccept message from the network.</p> <p>Information about the LMIC state for specific events can be obtained from the global <code>LMIC</code> structure described in section 2.4.</p> <p>Events functions and the transmit/receive call back functions are orthogonal. Multiple routines may be called for a given event.</p> <p>The sequence is as follows.</p> <ol> <li> <p>If using an <code>onEvent()</code> function (the LMIC is configured to use onEvent, and a function named onEvent is provided when using compilers that support weak references), the <code>onEvent()</code> function is called. (For compatibility, the event <code>EV_RXSTART</code> is never sent to the <code>onEvent()</code> function.)</p> </li> <li> <p>If the event indicates that a message was received, and a receive callback is registered, the receive callback is called.</p> </li> <li> <p>If the event indicates that a transmission has completed, and the message was sent with one of the callback APIs, the client callback is invoked.</p> </li> <li> <p>Finally, if the client has registered an event callback, the registered callback is invoked.</p> </li> </ol>"},{"location":"technical-specification/programming-model-and-api/api-functions/#receiving-downlink-data-with-an-event-function","title":"Receiving Downlink Data with an Event Function","text":"<p>When <code>EV_TXCOMPLETE</code> or <code>EV_RXCOMPLETE</code> is received, the event-processing code should check for downlink data, and pass it to the application. To do this, use code like the following.</p> <pre><code>// Any data to be received?\nif (LMIC.dataLen != 0) {\n// Data was received. Extract port number if any.\nu1_t bPort = 0;\nif (LMIC.txrxFlags &amp; TXRX_PORT)\nbPort = LMIC.frame[LMIC.dataBeg \u2013 1];\n// Call user-supplied function with port #, pMessage, nMessage\nreceiveMessage(\nbPort, LMIC.frame + LMIC.dataBeg, LMIC.dataLen\n);\n}\n</code></pre> <p>If you wish to support alerting the client for zero-length messages, slightly-more complex code must be used.</p> <pre><code>// Any data to be received?\nif (LMIC.dataLen != 0 || LMIC.dataBeg != 0) {\n// Data was received. Extract port number if any.\nu1_t bPort = 0;\nif (LMIC.txrxFlags &amp; TXRX_PORT)\nbPort = LMIC.frame[LMIC.dataBeg \u2013 1];\n// Call user-supplied function with port #, pMessage, nMessage;\n// nMessage might be zero.\nreceiveMessage(\nbPort, LMIC.frame + LMIC.dataBeg, LMIC.dataLen\n);\n}\n</code></pre>"},{"location":"technical-specification/programming-model-and-api/api-functions/#bit_t-lmic_enabletracking-u1_t-trybcninfo","title":"<code>bit_t LMIC_enableTracking (u1_t tryBcnInfo)</code>","text":"<p>Enable beacon tracking. A value of 0 for <code>tryBcnInfo</code> indicates to start scanning for the beacon immediately. A non-zero value specifies the number of attempts to query the server for the exact beacon arrival time. The query requests will be sent within the next upstream frames (no frame will be generated). If no answer is received scanning will be started. The events <code>EV_BEACON_FOUND</code> or <code>EV_SCAN_TIMEOUT</code> will be generated for the first beacon, and the events <code>EV_BEACON_TRACKED</code>, <code>EV_BEACON_MISSED</code> or <code>EV_LOST_TSYNC</code> will be generated for subsequent beacons.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_disabletracking","title":"<code>void LMIC_disableTracking ()</code>","text":"<p>Disable beacon tracking. The beacon will be no longer tracked and, therefore, also pinging will be disabled.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_setpingable-u1_t-intvexp","title":"<code>void LMIC_setPingable (u1_t intvExp)</code>","text":"<p>Enable pinging and set the downstream listen interval. Pinging will be enabled with the next upstream frame (no frame will be generated). The listen interval is 2^<code>intvExp</code> seconds, valid values for <code>intvExp</code> are 0-7. This API function requires a valid session established with the network server either via <code>LMIC_startJoining()</code> or <code>LMIC_setSession()</code> functions (see sections 2.5.2 and 2.5.4). If beacon tracking is not yet enabled, scanning will be started immediately. In order to avoid scanning, the beacon can be located more efficiently by a preceding call to <code>LMIC_enableTracking()</code> with a non-zero parameter. Additionally to the events mentioned for <code>LMIC_enableTracking()</code>, the event <code>EV_RXCOMPLETE</code> will be generated whenever downstream data has been received in a ping slot.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_stoppingable","title":"<code>void LMIC_stopPingable ()</code>","text":"<p>Stop listening for downstream data. Periodical reception is disabled, but beacons will still be tracked. In order to stop tracking, the beacon a call to <code>LMIC_disableTracking()</code> is required.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_sendalive","title":"<code>void LMIC_sendAlive ()</code>","text":"<p>Send one empty upstream MAC frame as soon as possible. Might be used to signal liveness or to transport pending MAC options, and to open a receive window.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_shutdown","title":"<code>void LMIC_shutdown ()</code>","text":"<p>Stop all MAC activity. Subsequently, the MAC needs to be reset via a call to <code>LMIC_reset()</code> and new protocol actions need to be initiated.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#void-lmic_requestnetworktime-lmic_request_network_time_cb_t-void-puserdata","title":"<code>void LMIC_requestNetworkTime (lmic_request_network_time_cb_t *, void *pUserData)</code>","text":"<p>Register a network time MAC request to be forwarded with the next uplink frame. The first argument is a pointer to a function, with the following signature.</p> <pre><code>typedef void LMIC_ABI_STD lmic_request_network_time_cb_t (void * pUserData, int flagSuccess);\n</code></pre> <p>This function is called after processing is complete. <code>flagSuccess</code> will be non-zero if time was successfully obtained, zero otherwise. <code>pUserData</code> in the callback will be set according to the value of <code>pUserData</code> in the original call to <code>LMIC_requestNetworkTime()</code>. If not used, please use a NULL pointer.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#int-lmic_getnetworktimereference-lmic_time_reference_t-preference","title":"<code>int LMIC_getNetworkTimeReference (lmic_time_reference_t *pReference)</code>","text":"<p>Fetch a time reference for the most-recently obtained network time. The <code>lmic_time_reference_t</code> structure at <code>pReference</code> is updated with the relevant information. The result of this call is a Boolean indicating whether a valid time was returned if non-zero, a valid time was returned, otherwise no valid time was available (or <code>pReference</code> was NULL). If unsuccessful, <code>*pReference</code> is not modified.</p> <p>The structure <code>lmic_time_reference_t</code> has the following fields.</p> <pre><code>typedef struct {\nostime_t tLocal;\nlmic_gpstime_t tNetwork;\n} lmic_time_reference_t;\n</code></pre> <p><code>tNetwork</code> is set to the GPS time transmitted by the network in the <code>DeviceTimeAns</code> message. <code>tLocal</code> is calculated, by converting the fractional part of the <code>DeviceTimeAns</code> message into OS ticks, and subtracting that from the completion time of the <code>DeviceTimeReq</code> message.</p> <p>The two fields establish a relationship between a given OS time <code>tLocal</code> and a given GPS time <code>tNetwork</code>. From this, you can work out the current OS time corresponding to a given GPS time, using a formula like <code>ostime = ref.tLocal + sec2osticks(gpstime \u2013 ref.tNetwork)</code>.</p>"},{"location":"technical-specification/programming-model-and-api/api-functions/#uint8_t-lmic_setbatterylevel-uint8_t-ubattlevel","title":"<code>uint8_t LMIC_setBatteryLevel (uint8_t uBattLevel)</code>","text":"<p>Set the battery level that will be returned to the network server by the MAC in <code>DevStatusAns</code> messages. The result of this call is the previous value. The internal value is initialized by <code>LMIC_init()</code> to <code>MCMD_DEVS_NOINFO</code>. The internal value is not changed by <code>LMIC_reset()</code>.</p> <p>The possible values of <code>uBattLevel</code> are:</p> Value Name Meaning 0 MCMD_DEVS_EXT_POWER Device is operating on external power. 0x01 MCMD_DEVS_BATT_MIN Device is operating on battery power; battery is at minimum value. \u2026 0xFE MCMD_DEVS_BATT_MAX Device is operating on battery power; battery is at maximum value 0xFF MCMD_DEVS_BATT_NOINFO The device doesn\u2019t know its battery / power state, and was unable to measure the battery level. <p>If the application knows the battery level as a % of capacity (from 0% to 100%, inclusive), it should calculate as follows.</p> <pre><code>uBattLevel = (MCMD_DEVS_BAT_MAX \u2013 MCMD_DEVS_BAT_MIN253 + 50) * uBatteryPercent / 100;\nuBattLevel += MCMD_DEVS_BAT_MIN;\nLMIC_setBatteryLevel(uBattLevel);\n</code></pre>"},{"location":"technical-specification/programming-model-and-api/api-functions/#uint8_t-lmic_getbatterylevel-void","title":"<code>uint8_t LMIC_getBatteryLevel (void)</code>","text":"<p>This function returns the battery level currently stored for use by the MAC. The value is as described in <code>LMIC_setBatteryLevel()</code>.</p>"},{"location":"technical-specification/programming-model-and-api/application-callbacks/","title":"Application callbacks","text":"<p>The LMIC library requires the application to implement a few callback functions. These functions are called by the state engine to query application-specific information and to deliver state events to the application.</p> <p>Upcalls by name from the LMIC to application code are deprecated and will be removed in future versions of the LMIC. The provisioning APIs (<code>os_getDevEui</code>, <code>os_getDevKey</code> and <code>os_getArtEui</code>) will be replaced by secure element APIs in version 4. The onEvent API will be disabled by default in version 4, and removed in version 5.</p>"},{"location":"technical-specification/programming-model-and-api/application-callbacks/#void-os_getdeveui-u1_t-buf","title":"<code>void os_getDevEui (u1_t* buf)</code>","text":"<p>The implementation of this callback function has to provide the device EUI and copy it to the given buffer. The device EUI is 8 bytes in length and is stored in little-endian format, that is, least-significant-byte-first (LSBF).</p>"},{"location":"technical-specification/programming-model-and-api/application-callbacks/#void-os_getdevkey-u1_t-buf","title":"<code>void os_getDevKey (u1_t* buf)</code>","text":"<p>The implementation of this callback function has to provide the device-specific cryptographic application key and copy it to the given buffer. The device-specific application key is a 128-bit AES key (16 bytes in length).</p>"},{"location":"technical-specification/programming-model-and-api/application-callbacks/#void-os_getarteui-u1_t-buf","title":"<code>void os_getArtEui (u1_t* buf)</code>","text":"<p>The implementation of this callback function has to provide the application EUI and copy it to the given buffer. The application EUI is 8 bytes in length and is stored in little-endian format, that is, least-significant-byte-first (LSBF).</p>"},{"location":"technical-specification/programming-model-and-api/application-callbacks/#void-onevent-ev_t-ev","title":"<code>void onEvent (ev_t ev)</code>","text":"<p>This function, if provided, is called to report LMIC events (such as transmission complete or downlink message received). It is a legacy function. In V3, if this name conflicts with a name in your application, you can disable the use of this name by putting the following in your configuration file:</p> <pre><code>#define LMIC_ENABLE_onEvent 0\n</code></pre> <p>Upcalls by name from the LMIC to application code are deprecated and will be removed in future versions of the LMIC. A suitable substitute is available. See the discussion of <code>LMIC_registerEventCb()</code>, below.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/","title":"Run-time Functions","text":"<p>The run-time functions mentioned before are used to control the run-time environment. This includes initialization, scheduling and execution of the run-time jobs.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_init","title":"<code>void os_init ()</code>","text":"<p>Initialize the operating system by calling <code>os_init_ex(NULL)</code>.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_init_ex-const-void-phaldata","title":"<code>void os_init_ex (const void* pHalData)</code>","text":"<p>To facilitate use of this library on multiple platforms, the <code>os_init_ex()</code> routine takes an arbitrary pointer to platform data. The Arduino LMIC default HAL implementation expects this pointer to be a reference to a C++ <code>struct lmic_pinmap</code> object. See README.md for more information.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_setcallback-osjob_t-job-osjobcb_t-cb","title":"<code>void os_setCallback (osjob_t* job, osjobcb_t cb)</code>","text":"<p>Prepare an immediately runnable job. This function can be called at any time, including from interrupt handler contexts (e.g. if a new sensor value has become available).</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_settimedcallback-osjob_t-job-ostime_t-time-osjobcb_t-cb","title":"<code>void os_setTimedCallback (osjob_t* job, ostime_t time, osjobcb_t cb)</code>","text":"<p>Schedule a timed job to run at the given timestamp (absolute system time). This function can be called at any time, including from interrupt handler contexts.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_clearcallback-osjob_t-job","title":"<code>void os_clearCallback (osjob_t* job)</code>","text":"<p>Cancel a run-time job. A previously scheduled run-time job is removed from timer and run queues. The job is identified by the address of the job struct. The function has no effect if the specified job is not yet scheduled.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_runloop","title":"<code>void os_runloop ()</code>","text":"<p>Execute run-time jobs from the timer and from the run queues. This function is the main action dispatcher. It does not return and must be run on the main thread. This routine is normally not used in Arduino environments, as it disables the normal calling of the Arduino <code>loop()</code> function.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#void-os_runloop_once","title":"<code>void os_runloop_once ()</code>","text":"<p>Execute run-time jobs from the timer and from the run queues. This function is just like <code>os_runloop()</code>, except that it returns after dispatching the first available job.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-os_gettime","title":"<code>ostime_t os_getTime ()</code>","text":"<p>Query absolute system time (in ticks).</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-us2osticks-s4_t-us","title":"<code>ostime_t us2osticks (s4_t us)</code>","text":"<p>Returns the ticks corresponding to the integer value <code>us</code>. This may be a function-like macro, so <code>us</code> may be evaluated more than once. Any fractional part of the calculation is discarded.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-us2osticksceil-s4_t-us","title":"<code>ostime_t us2osticksCeil (s4_t us)</code>","text":"<p>Returns the ticks corresponding to the integer value <code>us</code>. This may be a function-like macro, so <code>us</code> may be evaluated more than once. If the fractional part of the calculation is non-zero, the result is increased towards positive infinity.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-us2osticksround-s4_t-us","title":"<code>ostime_t us2osticksRound (s4_t us)</code>","text":"<p>Returns the ticks corresponding to the integer value <code>us</code>. This may be a function-like macro, so <code>us</code> may be evaluated more than once. The result is rounded to the nearest tick.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-ms2osticks-s4_t-ms","title":"<code>ostime_t ms2osticks (s4_t ms)</code>","text":"<p>Returns the ticks corresponding to the integer millisecond value ms. This may be a function-like macro, so ms may be evaluated more than once. If the fractional part of the calculation is non-zero, the result is increased towards positive infinity.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-ms2osticksceil-s4_t-ms","title":"<code>ostime_t ms2osticksCeil (s4_t ms)</code>","text":"<p>Returns the ticks corresponding to the integer millisecond value <code>ms</code>. This may be a function-like macro, so <code>ms</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-ms2osticksround-s4_t-ms","title":"<code>ostime_t ms2osticksRound (s4_t ms)</code>","text":"<p>Returns the ticks corresponding to the integer millisecond value <code>ms</code>. This may be a function-like macro, so <code>ms</code> may be evaluated more than once. The result is rounded to the nearest tick.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#ostime_t-sec2osticks-s4_t-sec","title":"<code>ostime_t sec2osticks (s4_t sec)</code>","text":"<p>Returns the ticks corresponding to the integer second value <code>sec</code>. This may be a function-like macro, so <code>sec</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#s4_t-osticks2ms-ostime_t-os","title":"<code>S4_t osticks2ms (ostime_t os)</code>","text":"<p>Returns the milliseconds corresponding to the tick value <code>os</code>. This may be a function-like macro, so <code>os</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/run-time-functions/#s4_t-osticks2us-ostime_t-os","title":"<code>S4_t osticks2us (ostime_t os)</code>","text":"<p>Returns the microseconds corresponding to the tick value <code>os</code>. This may be a function-like macro, so <code>os</code> may be evaluated more than once.</p>"},{"location":"technical-specification/programming-model-and-api/the-lmic-struct/","title":"The LMIC Struct","text":"<p>Instead of passing numerous parameters back and forth between API and callback functions, information about the protocol state can be accessed via a global <code>LMIC</code> structure as shown below. All fields besides the ones explicitly mentioned below are read-only and should not be modified.</p> <pre><code>struct lmic_t {\nu1_t      frame[MAX_LEN_FRAME];\nu1_t      dataLen;    // 0 no data or zero length data, &gt;0 byte count of data\nu1_t      dataBeg;    // 0 or start of data (dataBeg-1 is port)\nu1_t      txCnt;\nu1_t      txrxFlags;  // transaction flags (TX-RX combo)\nu1_t      pendTxPort;\nu1_t      pendTxConf; // confirmed data\nu1_t      pendTxLen;\nu1_t      pendTxData[MAX_LEN_PAYLOAD];\nu1_t      bcnChnl;\nu1_t      bcnRxsyms;\nostime_t  bcnRxtime;\nbcninfo_t bcninfo;    // Last received beacon info\n\u2026\n\u2026\n};\n</code></pre> <p>This document does not describe the full struct in detail since most of the fields of the LMIC struct are used internally only. The most important fields to examine on reception (event <code>EV_RXCOMPLETE</code> or <code>EV_TXCOMPLETE</code>) are the <code>txrxFlags</code> for status information and <code>frame[]</code> and <code>dataLen</code> / <code>dataBeg</code> for the received application payload data. For data transmission the most important fields are <code>pendTxData[]</code>, <code>pendTxLen</code>, <code>pendTxPort</code> and <code>pendTxConf</code>, which are used as input to the <code>LMIC_setTxData()</code> API function (see 2.5.13).</p> <p>For the <code>EV_RXCOMPLETE</code> and <code>EV_TXCOMPLETE</code> events, the <code>txrxFlags</code> field should be evaluated. The following flags are defined:</p> <ul> <li> <p><code>TXRX_ACK</code>: confirmed UP frame was acked (mutually exclusive with <code>TXRX_NACK</code>)</p> </li> <li> <p><code>TXRX_NACK</code>: confirmed UP frame was not acked (mutually exclusive with <code>TXRX_ACK</code>)</p> </li> <li> <p><code>TXRX_PORT</code>: a port byte is contained in the received frame at offset LMIC.dataBeg \u2013 1.</p> </li> <li> <p><code>TXRX_NOPORT</code>: no port byte is available.</p> </li> <li> <p><code>TXRX_DNW1</code>: received in first DOWN slot (mutually exclusive with <code>TXRX_DNW2</code>)</p> </li> <li> <p><code>TXRX_DNW2</code>: received in second DOWN slot (mutually exclusive with <code>TXRX_DNW1</code>)</p> </li> <li> <p><code>TXRX_PING</code>: received in a scheduled RX slot</p> </li> <li> <p><code>TXRX_LENERR</code>: the transmitted message was abandoned because it was longer than the established data rate.</p> </li> </ul> <p>For the <code>EV_TXCOMPLETE</code> event the fields have the following values:</p> Received frame LMIC.txrxFlags LMIC.dataLen LMIC.dataBeg ACK NACK PORT NOPORT DNW1 DNW2 PING LENERR nothing 0 0 0 1 0 0 0 0 0 0 empty frame x x 0 1 x x 0 0 0 x port only x x 1 0 x x 0 0 0 x port+payload x x 1 0 x x 0 0 x X No message received, transmit message too long 0 0 0 1 x x x 1 0 0 <p>For the <code>EV_RXCOMPLETE</code> event the fields have the following values:</p> Received frame LMIC.txrxFlags LMIC.dataLen LMIC.dataBeg ACK NACK PORT NOPORT DNW1 DNW2 PING empty frame 0 0 0 1 0 0 1 0 x port only 0 0 1 0 0 0 1 0 x port+payload 0 0 1 0 0 0 1 x x"}]}